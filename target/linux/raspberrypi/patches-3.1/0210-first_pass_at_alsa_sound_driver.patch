From 6b9b2f8199f98268df15e0f8acd0d6051894ed7d Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 26 Mar 2012 22:15:50 +0100
Subject: [PATCH] First pass at alsa sound driver. Some functionality, but
 also some underruns


diff --git a/arch/arm/mach-bcm2708/bcm2708.c b/arch/arm/mach-bcm2708/bcm2708.c
index 1db8261..aedca70 100644
--- a/arch/arm/mach-bcm2708/bcm2708.c
+++ b/arch/arm/mach-bcm2708/bcm2708.c
@@ -467,6 +467,16 @@ struct platform_device bcm2708_powerman_device = {
 		.coherent_dma_mask = 0xffffffffUL},
 };
 
+
+static struct platform_device bcm2708_alsa_devices[] = {
+	[0] =	{
+		.name = "bcm2835_AUD0",
+		.id = 0,		/* first audio device */
+		.resource = 0,
+		.num_resources = 0,
+		},
+};
+
 int __init bcm_register_device(struct platform_device *pdev)
 {
 	int ret;
@@ -503,6 +513,8 @@ void __init bcm2708_init(void)
 	bcm_register_device(&bcm2708_emmc_device);
 #endif
 	bcm2708_init_led();
+	for (i = 0; i < ARRAY_SIZE(bcm2708_alsa_devices); i++)
+		bcm_register_device(&bcm2708_alsa_devices[i]);
 
 #ifdef CONFIG_BCM2708_VCMEM
 	{
diff --git a/sound/arm/Kconfig b/sound/arm/Kconfig
index 885683a..3577572 100644
--- a/sound/arm/Kconfig
+++ b/sound/arm/Kconfig
@@ -39,5 +39,12 @@ config SND_PXA2XX_AC97
 	  Say Y or M if you want to support any AC97 codec attached to
 	  the PXA2xx AC97 interface.
 
+config SND_BCM2835
+	tristate "BCM2835 ALSA driver"
+	depends on ARCH_BCM2708 && SND
+	select SND_PCM
+	help
+	  Say Y or M if you want to support BCM2835 Alsa pcm card driver
+
 endif	# SND_ARM
 
diff --git a/sound/arm/Makefile b/sound/arm/Makefile
index 8c0c851..3939156 100644
--- a/sound/arm/Makefile
+++ b/sound/arm/Makefile
@@ -14,3 +14,9 @@ snd-pxa2xx-lib-$(CONFIG_SND_PXA2XX_LIB_AC97)	+= pxa2xx-ac97-lib.o
 
 obj-$(CONFIG_SND_PXA2XX_AC97)	+= snd-pxa2xx-ac97.o
 snd-pxa2xx-ac97-objs		:= pxa2xx-ac97.o
+
+obj-$(CONFIG_SND_BCM2835)	+= snd-bcm2835.o
+snd-bcm2835-objs		:= bcm2835.o bcm2835-ctl.o bcm2835-pcm.o bcm2835-vchiq.o
+
+EXTRA_CFLAGS += -Idrivers/misc/vc04_services -Idrivers/misc/vc04_services/interface/vcos/linuxkernel
+
diff --git a/sound/arm/bcm2835-ctl.c b/sound/arm/bcm2835-ctl.c
new file mode 100755
index 0000000..20a24b8
--- /dev/null
+++ b/sound/arm/bcm2835-ctl.c
@@ -0,0 +1,168 @@
+/*****************************************************************************
+* Copyright 2011 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*	
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/jiffies.h>
+#include <linux/slab.h>
+#include <linux/time.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+#include <linux/moduleparam.h>
+#include <linux/sched.h>
+
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/rawmidi.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+
+#include "bcm2835.h"
+
+static int snd_bcm2835_ctl_info(struct snd_kcontrol * kcontrol,
+		struct snd_ctl_elem_info * uinfo)
+{
+	if (kcontrol->private_value == PCM_PLAYBACK_VOLUME) {
+		uinfo->type			= SNDRV_CTL_ELEM_TYPE_INTEGER;
+		uinfo->count			= 1;
+		uinfo->value.integer.min	= -10240;
+		uinfo->value.integer.max	= 2303;
+	} else if (kcontrol->private_value == PCM_PLAYBACK_MUTE) {
+		uinfo->type			= SNDRV_CTL_ELEM_TYPE_INTEGER;
+		uinfo->count			= 1;
+		uinfo->value.integer.min	= 0;
+		uinfo->value.integer.max	= 1;
+	} else if (kcontrol->private_value == PCM_PLAYBACK_DEVICE) {
+		uinfo->type			= SNDRV_CTL_ELEM_TYPE_INTEGER;
+		uinfo->count			= 1;
+		uinfo->value.integer.min	= AUDIO_DEST_LOCAL;
+		uinfo->value.integer.max	= AUDIO_DEST_ALL;
+	}
+
+	return 0;
+}
+
+static int snd_bcm2835_ctl_get(struct snd_kcontrol * kcontrol, struct snd_ctl_elem_value * ucontrol)
+{
+	struct bcm2835_chip *chip = snd_kcontrol_chip(kcontrol);
+
+	BUG_ON(!chip && !(chip->avail_substreams & AVAIL_SUBSTREAMS_MASK));
+
+	if (kcontrol->private_value == PCM_PLAYBACK_VOLUME)
+		ucontrol->value.integer.value[0] = chip->volume;
+	else if (kcontrol->private_value == PCM_PLAYBACK_MUTE)
+		ucontrol->value.integer.value[0] = chip->mute;
+	else if (kcontrol->private_value == PCM_PLAYBACK_DEVICE)
+		ucontrol->value.integer.value[0] = chip->dest;
+
+	return 0;
+}
+
+static int snd_bcm2835_ctl_put(struct snd_kcontrol * kcontrol, struct snd_ctl_elem_value * ucontrol)
+{
+	struct bcm2835_chip *chip = snd_kcontrol_chip(kcontrol);
+	int changed = 0;
+
+	if (kcontrol->private_value == PCM_PLAYBACK_VOLUME) {
+		if (chip->mute) {
+			chip->mute = 0;
+			changed = 1;
+		}
+		if (changed || (ucontrol->value.integer.value[0] != chip->volume)) {
+			int atten;
+
+			chip->volume = ucontrol->value.integer.value[0];
+			changed = 1;
+			atten = -((chip->volume << 8) / 100);
+			chip->volume = atten;
+		}
+
+	} else if (kcontrol->private_value == PCM_PLAYBACK_MUTE) {
+		// Not implemented
+		if (ucontrol->value.integer.value[0] != chip->mute) {
+			chip->mute = ucontrol->value.integer.value[0];
+			changed = 0;
+		}
+	} else if (kcontrol->private_value == PCM_PLAYBACK_DEVICE) {
+		if (ucontrol->value.integer.value[0] != chip->dest && ucontrol->value.integer.value[0] != 1) {
+			chip->dest= ucontrol->value.integer.value[0];
+			changed = 1;
+		}
+	}
+
+	if (changed) {
+		if (bcm2835_audio_set_ctls(chip))
+			printk(KERN_ERR"Failed to set ALSA controls..\n");
+	}
+
+	return changed;
+}
+
+static DECLARE_TLV_DB_SCALE(snd_bcm2835_db_scale, -10240, 1, 1);
+
+static struct snd_kcontrol_new snd_bcm2835_ctl[] __devinitdata =
+{
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name  = "PCM Playback Volume",
+		.index = 0,
+		.access= SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE,
+		.private_value = PCM_PLAYBACK_VOLUME,
+		.info  = snd_bcm2835_ctl_info,
+		.get   = snd_bcm2835_ctl_get,
+		.put   = snd_bcm2835_ctl_put,
+		.count = 1,
+		.tlv = { .p = snd_bcm2835_db_scale }
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name  = "PCM Playback Switch",
+		.index = 0,
+		.access= SNDRV_CTL_ELEM_ACCESS_READWRITE,
+		.private_value = PCM_PLAYBACK_MUTE,
+		.info  = snd_bcm2835_ctl_info,
+		.get   = snd_bcm2835_ctl_get,
+		.put   = snd_bcm2835_ctl_put,
+		.count = 1,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name  = "PCM Playback Route",
+		.index = 0,
+		.access= SNDRV_CTL_ELEM_ACCESS_READWRITE,
+		.private_value = PCM_PLAYBACK_DEVICE,
+		.info  = snd_bcm2835_ctl_info,
+		.get   = snd_bcm2835_ctl_get,
+		.put   = snd_bcm2835_ctl_put,
+		.count = 1,
+	},
+};
+
+int __devinit snd_bcm2835_new_ctl(bcm2835_chip_t *chip)
+{
+	int err;
+	unsigned int idx;
+
+	strcpy(chip->card->mixername, "Broadcom Mixer");
+	for (idx = 0; idx < ARRAY_SIZE(snd_bcm2835_ctl); idx++)
+	{
+		err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_bcm2835_ctl[idx], chip));
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
diff --git a/sound/arm/bcm2835-pcm.c b/sound/arm/bcm2835-pcm.c
new file mode 100755
index 0000000..8adacc8
--- /dev/null
+++ b/sound/arm/bcm2835-pcm.c
@@ -0,0 +1,391 @@
+/*****************************************************************************
+* Copyright 2011 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*	
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+
+#include "bcm2835.h"
+
+/* hardware definition */
+static struct snd_pcm_hardware snd_bcm2835_playback_hw = {
+	.info = ( SNDRV_PCM_INFO_INTERLEAVED |
+		SNDRV_PCM_INFO_BLOCK_TRANSFER ),
+	.formats =          SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =            SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
+	.rate_min =         8000,
+	.rate_max =         48000,
+	.channels_min =     1,
+	.channels_max =     2,
+	.buffer_bytes_max = (4*8-1)*1024, /* Needs to be less than audioplay buffer size */
+	.period_bytes_min = 1*1024,
+	.period_bytes_max = (4*8-1)*1024,
+	.periods_min =      1,
+	.periods_max =      4*8-1,
+};
+
+
+static void snd_bcm2835_playback_free(struct snd_pcm_runtime *runtime)
+{
+	audio_info("Freeing up alsa stream here ..\n");
+	if (runtime->private_data)
+		kfree(runtime->private_data);
+	runtime->private_data = NULL;
+}
+
+static irqreturn_t bcm2835_playback_fifo_irq(int irq, void *dev_id)
+{
+	bcm2835_alsa_stream_t *alsa_stream = (bcm2835_alsa_stream_t *)dev_id;
+	uint32_t consumed = 0;
+	int new_period = 0;
+
+	audio_debug(" .. IN\n");
+
+	audio_info("alsa_stream=%p substream=%p\n", alsa_stream, alsa_stream ? alsa_stream->substream:0);
+
+	if (alsa_stream->open)
+		consumed = bcm2835_audio_retrieve_buffers(alsa_stream);
+
+	/* We get called only if playback was triggered, So, the number of buffers we retrieve in
+	 * each iteration are the buffers that have been played out already
+	 */
+
+	if (alsa_stream->period_size) {
+		if ((alsa_stream->pos / alsa_stream->period_size) != ((alsa_stream->pos+consumed) / alsa_stream->period_size))
+			new_period = 1;
+	}
+	audio_warning("updating pos cur: %d + %d max:%d new_period:%d\n", alsa_stream->pos,
+			(consumed /** AUDIO_IPC_BLOCK_BUFFER_SIZE*/), alsa_stream->buffer_size, new_period);
+	if (alsa_stream->buffer_size) {
+		alsa_stream->pos += consumed;
+		alsa_stream->pos %= alsa_stream->buffer_size;
+    	}
+	if (alsa_stream->substream) {
+		if (new_period)
+			snd_pcm_period_elapsed(alsa_stream->substream);
+	} else {
+		audio_debug(" unexpected NULL substream\n");
+	}
+	audio_debug(" .. OUT\n");
+
+	return IRQ_HANDLED;
+}
+
+/* open callback */
+static int snd_bcm2835_playback_open(struct snd_pcm_substream *substream)
+{
+	bcm2835_chip_t *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	bcm2835_alsa_stream_t *alsa_stream;
+	int idx;
+	int err;
+
+	audio_info(" .. IN (%d)\n", substream->number);
+
+	audio_warning(" .. open (%d)\n", substream->number);
+	idx = substream->number;
+
+	if (idx > MAX_SUBSTREAMS) {
+		audio_error("substream(%d) device doesn't exist max(%d) substreams allowed\n", idx, MAX_SUBSTREAMS);
+		err = -ENODEV;
+		goto out;
+	}
+
+	/* Check if we are ready */
+	if (!(chip->avail_substreams & (1 << idx))) {
+		/* We are not ready yet */
+		audio_error("substream(%d) device is not ready yet\n", idx);
+		err = -EAGAIN;
+		goto out;
+	}
+
+	alsa_stream = kzalloc(sizeof(bcm2835_alsa_stream_t), GFP_KERNEL);
+	if (alsa_stream == NULL) {
+		return -ENOMEM;
+	}
+
+	/* Initialise alsa_stream */
+	alsa_stream->chip = chip;
+	alsa_stream->substream = substream;
+	chip->alsa_stream[idx] = alsa_stream;
+
+	sema_init(&alsa_stream->buffers_update_sem, 0);
+	sema_init(&alsa_stream->control_sem, 0);
+	spin_lock_init(&alsa_stream->lock);
+
+	/* Enabled in start trigger, called on each "fifo irq" after that */
+	alsa_stream->enable_fifo_irq = 0;
+	alsa_stream->fifo_irq_handler = bcm2835_playback_fifo_irq;
+
+	runtime->private_data = alsa_stream;
+	runtime->private_free = snd_bcm2835_playback_free;
+	runtime->hw = snd_bcm2835_playback_hw;
+
+	/* minimum 16 bytes alignment (for vchiq bulk transfers) */
+	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 16);
+
+	err = bcm2835_audio_open(alsa_stream);
+	if (err != 0) {
+		kfree(alsa_stream);
+		return err;
+	}
+
+	alsa_stream->open = 1;
+	alsa_stream->draining = 1;
+
+out:
+	audio_debug(" .. OUT =%d\n", err);
+
+	return err;
+}
+
+/* close callback */
+static int snd_bcm2835_playback_close(struct snd_pcm_substream *substream)
+{
+	/* the hardware-specific codes will be here */
+
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	bcm2835_alsa_stream_t *alsa_stream = runtime->private_data;
+
+	audio_debug(" .. IN\n");
+	audio_warning("Alsa close\n");
+
+	/*
+	 * Call stop if it's still running. This happens when app
+	 * is force killed and we don't get a stop trigger.
+	 */
+	if (alsa_stream->running) {
+		int err;
+		err = bcm2835_audio_stop(alsa_stream);
+		alsa_stream->running = 0;
+		if (err != 0)
+			audio_error(" Failed to STOP alsa device\n");
+	}
+
+	alsa_stream->period_size = 0;
+	alsa_stream->buffer_size = 0;
+
+	if (alsa_stream->open) {
+		alsa_stream->open = 0;
+		bcm2835_audio_close(alsa_stream);
+	}
+
+	/*
+	 * Do not free up alsa_stream here, it will be freed up by
+	 * runtime->private_free callback we registered in *_open above
+	 */
+
+	audio_debug(" .. OUT\n");
+
+	return 0;
+}
+
+/* hw_params callback */
+static int snd_bcm2835_pcm_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params)
+{
+	int err;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	bcm2835_alsa_stream_t *alsa_stream = (bcm2835_alsa_stream_t *)runtime->private_data;
+
+	audio_debug(" .. IN\n");
+
+	err = snd_pcm_lib_malloc_pages(substream,
+			params_buffer_bytes(params));
+	if (err < 0) {
+		audio_error(" pcm_lib_malloc failed to allocated pages for buffers\n");
+		return err;
+	}
+
+	err = bcm2835_audio_set_params(alsa_stream, params_channels(params),
+			params_rate(params), snd_pcm_format_width(params_format(params)));
+	if (err < 0) {
+		audio_error(" error setting hw params\n");
+	}
+
+	bcm2835_audio_setup(alsa_stream);
+	audio_debug(" .. OUT\n");
+
+	return err;
+}
+
+/* hw_free callback */
+static int snd_bcm2835_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	audio_debug(" .. IN\n");
+	return snd_pcm_lib_free_pages(substream);
+}
+
+/* prepare callback */
+static int snd_bcm2835_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	bcm2835_alsa_stream_t *alsa_stream = runtime->private_data;
+
+	audio_debug(" .. IN\n");
+
+	alsa_stream->buffer_size = snd_pcm_lib_buffer_bytes(substream);
+	alsa_stream->period_size = snd_pcm_lib_period_bytes(substream);
+	alsa_stream->pos = 0;
+
+	audio_warning("buffer_size=%d, period_size=%d pos=%d frame_bits=%d\n", alsa_stream->buffer_size, alsa_stream->period_size, alsa_stream->pos, runtime->frame_bits);
+
+	audio_debug(" .. OUT\n");
+	return 0;
+}
+
+/* trigger callback */
+static int snd_bcm2835_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	bcm2835_alsa_stream_t *alsa_stream = runtime->private_data;
+	int err = 0;
+
+	audio_debug(" .. IN\n");
+
+	switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+			audio_warning("bcm2835_AUDIO_TRIGGER_START running=%d\n", alsa_stream->running);
+			if (!alsa_stream->running) {
+				err = bcm2835_audio_start(alsa_stream);
+				if (err == 0)
+				{
+					alsa_stream->running = 1;
+					alsa_stream->draining = 1;
+				}
+			}
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+			audio_warning("bcm2835_AUDIO_TRIGGER_STOP running=%d draining=%d\n", runtime->status->state==SNDRV_PCM_STATE_DRAINING, alsa_stream->running);
+			if (runtime->status->state==SNDRV_PCM_STATE_DRAINING)
+			{
+				audio_info("DRAINING\n");
+				alsa_stream->draining = 1;
+			}
+                        else
+                        {
+                                audio_info("DROPPING\n");
+                                alsa_stream->draining=0;
+                        }
+			if (alsa_stream->running) {
+				err = bcm2835_audio_stop(alsa_stream);
+				if (err != 0)
+					audio_error(" Failed to STOP alsa device\n");
+				alsa_stream->running = 0;
+			}
+			break;
+		default:
+			err = -EINVAL;
+	}
+
+	audio_debug(" .. OUT\n");
+	return err;
+}
+
+/* pointer callback */
+static snd_pcm_uframes_t
+snd_bcm2835_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	bcm2835_alsa_stream_t *alsa_stream = runtime->private_data;
+
+	audio_debug(" .. IN\n");
+
+	audio_warning("pcm_pointer... (%d) hwptr=%d appl=%d pos=%d\n", 0,
+		frames_to_bytes(runtime, runtime->status->hw_ptr), frames_to_bytes(runtime, runtime->control->appl_ptr), alsa_stream->pos);
+
+	audio_debug(" .. OUT\n");
+	return bytes_to_frames(runtime, alsa_stream->pos);
+}
+
+static int snd_bcm2835_pcm_copy(struct snd_pcm_substream *substream, int channel,
+		snd_pcm_uframes_t pos, void *src, snd_pcm_uframes_t count)
+{
+	int ret;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	bcm2835_alsa_stream_t *alsa_stream = runtime->private_data;
+
+	audio_debug(" .. IN\n");
+	audio_warning("copy.......... (%d) hwptr=%d appl=%d pos=%d\n", frames_to_bytes(runtime, count), 
+		frames_to_bytes(runtime, runtime->status->hw_ptr), frames_to_bytes(runtime, runtime->control->appl_ptr), alsa_stream->pos);
+	ret = bcm2835_audio_write(alsa_stream, frames_to_bytes(runtime, count), src);
+	audio_debug(" .. OUT\n");
+	return ret;
+}
+
+static int snd_bcm2835_pcm_silence(struct snd_pcm_substream *substream, int channel,
+		snd_pcm_uframes_t post, snd_pcm_uframes_t count)
+{
+	int ret;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	bcm2835_alsa_stream_t *alsa_stream = runtime->private_data;
+
+	audio_debug(" .. IN\n");
+	audio_warning("silence....... (%d) hwptr=%d appl=%d pos=%d\n", frames_to_bytes(runtime, count),
+		frames_to_bytes(runtime, runtime->status->hw_ptr), frames_to_bytes(runtime, runtime->control->appl_ptr), alsa_stream->pos);
+	ret = bcm2835_audio_write(alsa_stream, frames_to_bytes(runtime, count), NULL);
+	audio_debug(" .. OUT\n");
+	return ret;
+}
+
+static int snd_bcm2835_pcm_lib_ioctl (	struct snd_pcm_substream * substream, unsigned int cmd, void * arg)
+{
+	int ret = snd_pcm_lib_ioctl(substream, cmd, arg);
+	audio_debug(" .. substream=%p, cmd=%d, arg=%p (%x) ret=%d\n", substream, cmd, arg, arg ? *(unsigned *)arg:0, ret);
+	return ret;
+}
+ 
+/* operators */
+static struct snd_pcm_ops snd_bcm2835_playback_ops = {
+	.open =        snd_bcm2835_playback_open,
+	.close =       snd_bcm2835_playback_close,
+	.ioctl =       snd_bcm2835_pcm_lib_ioctl,
+	.hw_params =   snd_bcm2835_pcm_hw_params,
+	.hw_free =     snd_bcm2835_pcm_hw_free,
+	.prepare =     snd_bcm2835_pcm_prepare,
+	.trigger =     snd_bcm2835_pcm_trigger,
+	.pointer =     snd_bcm2835_pcm_pointer,
+	.copy    =     snd_bcm2835_pcm_copy,
+	.silence =     snd_bcm2835_pcm_silence,
+};
+
+/* create a pcm device */
+int __devinit snd_bcm2835_new_pcm(bcm2835_chip_t *chip)
+{
+	struct snd_pcm *pcm;
+	int err;
+
+	audio_debug(" .. IN\n");
+	err = snd_pcm_new(chip->card, "bcm2835 ALSA", 0, MAX_SUBSTREAMS, 0, &pcm);
+	if (err < 0) 
+		return err;
+	pcm->private_data = chip;
+	strcpy(pcm->name, "bcm2835 ALSA");
+	chip->pcm = pcm;
+	chip->dest = AUDIO_DEST_LOCAL;
+	chip->volume = 100;
+	/* set operators */
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+			&snd_bcm2835_playback_ops);
+
+	/* pre-allocation of buffers */
+	/* NOTE: this may fail */
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,
+			snd_dma_continuous_data(GFP_KERNEL), 64*1024, 64*1024);
+
+	audio_debug(" .. OUT\n");
+
+	return 0;
+}
+
+
diff --git a/sound/arm/bcm2835-vchiq.c b/sound/arm/bcm2835-vchiq.c
new file mode 100755
index 0000000..cef8597
--- /dev/null
+++ b/sound/arm/bcm2835-vchiq.c
@@ -0,0 +1,863 @@
+/*****************************************************************************
+* Copyright 2011 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*	
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+#include <linux/device.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/mm.h>
+#include <linux/syscalls.h>
+#include <asm/uaccess.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/atomic.h>
+
+#include "bcm2835.h"
+
+
+// ---- Include Files --------------------------------------------------------
+
+#include "interface/vchi/vchi.h"
+#include "interface/vcos/vcos.h"
+#include "interface/vcos/vcos_logging.h"
+#include "vc_vchi_audioserv_defs.h"
+
+// ---- Private Constants and Types ------------------------------------------
+
+// VCOS logging category for this service
+#define VCOS_LOG_CATEGORY (&audio_log_category)
+
+// Default VCOS logging level
+#define LOG_LEVEL  VCOS_LOG_TRACE
+
+// Logging macros (for remapping to other logging mechanisms, i.e., printf)
+#define LOG_ERR( fmt, arg... )   pr_err(fmt, ##arg) //vcos_log_error( fmt, ##arg )
+#define LOG_WARN( fmt, arg... )  pr_err(fmt, ##arg) //vcos_log_warn( fmt, ##arg )
+#define LOG_INFO( fmt, arg... )  pr_err(fmt, ##arg) //vcos_log_info( fmt, ##arg )
+#define LOG_DBG( fmt, arg... )   pr_err( fmt, ##arg )
+
+typedef struct opaque_AUDIO_INSTANCE_T {
+	uint32_t num_connections;
+	VCHI_SERVICE_HANDLE_T vchi_handle[VCHI_MAX_NUM_CONNECTIONS];
+	VCOS_EVENT_T msg_avail_event;
+	VCOS_MUTEX_T vchi_mutex;
+	bcm2835_alsa_stream_t *alsa_stream;
+	int32_t result, got_result;
+	atomic_t callbacks_expected, callbacks_received;
+} AUDIO_INSTANCE_T;
+
+// ---- Private Variables ----------------------------------------------------
+
+// VCOS logging category for this service
+static VCOS_LOG_CAT_T audio_log_category;
+
+// ---- Private Function Prototypes ------------------------------------------
+
+// ---- Private Functions ----------------------------------------------------
+
+static int bcm2835_audio_stop_worker(bcm2835_alsa_stream_t * alsa_stream);
+static int bcm2835_audio_start_worker(bcm2835_alsa_stream_t * alsa_stream);
+
+#if 1
+typedef struct {
+  struct work_struct my_work;
+  bcm2835_alsa_stream_t *alsa_stream;
+  int    x;
+} my_work_t;
+
+static void my_wq_function( struct work_struct *work)
+{
+  my_work_t *w = (my_work_t *)work;
+  int ret=-9;
+  audio_debug(" .. IN %p:%d\n", w->alsa_stream, w->x);  
+  switch (w->x) {
+    case 1: ret=bcm2835_audio_start_worker(w->alsa_stream); break;
+    case 2: ret=bcm2835_audio_stop_worker(w->alsa_stream); break;
+    default:  audio_error(" Unexpected work: %p:%d\n", w->alsa_stream, w->x); break;
+  }
+  kfree( (void *)work );
+  audio_debug(" .. OUT %d\n", ret);  
+}
+
+int bcm2835_audio_start(bcm2835_alsa_stream_t *alsa_stream)
+{
+  int ret = -1;
+  audio_debug(" .. IN\n");
+  if (alsa_stream->my_wq) {
+    my_work_t *work = kmalloc(sizeof(my_work_t), GFP_KERNEL);
+    /* Queue some work (item 1) */
+    if (work) {
+      INIT_WORK( (struct work_struct *)work, my_wq_function );
+      work->alsa_stream = alsa_stream;
+      work->x = 1;
+      if (queue_work( alsa_stream->my_wq, (struct work_struct *)work ))
+        ret = 0;
+    } else
+      audio_error(" .. Error: NULL work kmalloc\n"); 
+  }
+  audio_debug(" .. OUT %d\n", ret);  
+  return ret;
+}
+
+int bcm2835_audio_stop(bcm2835_alsa_stream_t * alsa_stream)
+{
+  int ret = -1;
+  audio_debug(" .. IN\n");
+  if (alsa_stream->my_wq) {
+    my_work_t *work = kmalloc(sizeof(my_work_t), GFP_KERNEL);
+    /* Queue some work (item 1) */
+    if (work) {
+      INIT_WORK( (struct work_struct *)work, my_wq_function );
+      work->alsa_stream = alsa_stream;
+      work->x = 2;
+      if (queue_work( alsa_stream->my_wq, (struct work_struct *)work ))
+        ret = 0;
+    } else
+      audio_error(" .. Error: NULL work kmalloc\n"); 
+  }
+  audio_debug(" .. OUT %d\n", ret);  
+  return ret;
+}
+
+void my_workqueue_init(bcm2835_alsa_stream_t * alsa_stream)
+{
+  alsa_stream->my_wq = create_workqueue("my_queue");
+}
+
+void my_workqueue_quit(bcm2835_alsa_stream_t * alsa_stream)
+{
+  if (alsa_stream->my_wq) {
+    flush_workqueue( alsa_stream->my_wq );
+    destroy_workqueue( alsa_stream->my_wq );
+    alsa_stream->my_wq = NULL;
+  }
+}
+
+#else
+static void *my_tasklet_data;
+
+/* Bottom Half Function */
+void my_tasklet_function( unsigned long data )
+{
+	int err = 0;
+	bcm2835_alsa_stream_t *alsa_stream = (bcm2835_alsa_stream_t *)my_tasklet_data;
+	audio_info("IN ..(%d)\n", (int)data);
+	if (data)
+		err = bcm2835_audio_stop_worker(alsa_stream);
+	else
+		err = bcm2835_audio_start_worker(alsa_stream);
+	if (err != 0)
+		audio_error(" Failed to START/STOP alsa device\n");
+	audio_info("OUT ..\n");
+}
+
+DECLARE_TASKLET( my_tasklet_start, my_tasklet_function, 0);
+DECLARE_TASKLET( my_tasklet_stop, my_tasklet_function, 1);
+
+
+int bcm2835_audio_start(bcm2835_alsa_stream_t * alsa_stream)
+{
+				my_tasklet_data = alsa_stream;
+				  tasklet_schedule( &my_tasklet_stop );
+
+}
+int bcm2835_audio_stop(bcm2835_alsa_stream_t * alsa_stream)
+{
+				my_tasklet_data = alsa_stream;
+				  tasklet_schedule( &my_tasklet_start );
+}
+void my_workqueue_init(bcm2835_alsa_stream_t * alsa_stream){}
+void my_workqueue_quit(bcm2835_alsa_stream_t * alsa_stream){}
+
+#endif
+static void audio_vchi_callback(void *param,
+				const VCHI_CALLBACK_REASON_T reason,
+				void *msg_handle)
+{
+	AUDIO_INSTANCE_T *instance = (AUDIO_INSTANCE_T *)param;
+	int32_t status;
+	int32_t msg_len;
+	VC_AUDIO_MSG_T m;
+	bcm2835_alsa_stream_t *alsa_stream = 0;
+	audio_debug(" .. IN instance=%p, param=%p, reason=%d, handle=%p outstanding_completes=%d\n", instance, param, reason, msg_handle, atomic_read(&instance->callbacks_expected)-atomic_read(&instance->callbacks_received));
+
+	if (!instance || reason != VCHI_CALLBACK_MSG_AVAILABLE) {
+		return;
+	}
+	alsa_stream = instance->alsa_stream;
+	status = vchi_msg_dequeue(instance->vchi_handle[0],
+				   &m, sizeof m, &msg_len, VCHI_FLAGS_NONE);
+	if (m.type == VC_AUDIO_MSG_TYPE_RESULT) {
+		audio_debug(" .. instance=%p, m.type=VC_AUDIO_MSG_TYPE_RESULT, success=%d\n", instance, m.u.result.success);
+		BUG_ON(instance->got_result);
+		instance->result = m.u.result.success;
+		instance->got_result = 1;
+		vcos_event_signal(&instance->msg_avail_event);
+	} else if (m.type == VC_AUDIO_MSG_TYPE_COMPLETE) {
+		irq_handler_t callback = (irq_handler_t)m.u.complete.callback;
+		audio_debug(" .. instance=%p, m.type=VC_AUDIO_MSG_TYPE_COMPLETE, complete=%d\n", instance, m.u.complete.count);
+		if (alsa_stream && callback) {
+			atomic_add(m.u.complete.count, &alsa_stream->retrieved);
+			callback(0, alsa_stream);
+		} else {
+			audio_debug(" .. unexpected alsa_stream=%p, callback=%p\n", alsa_stream, callback);
+		}
+		atomic_inc(&instance->callbacks_received);
+		//BUG_ON(atomic_read(&instance->callbacks_expected)-atomic_read(&instance->callbacks_received) < 0);
+		vcos_event_signal(&instance->msg_avail_event);
+	} else {
+		audio_debug(" .. unexpected m.type=%d\n", m.type);
+	}
+}
+
+static AUDIO_INSTANCE_T *vc_vchi_audio_init(VCHI_INSTANCE_T vchi_instance,
+					  VCHI_CONNECTION_T ** vchi_connections,
+					  uint32_t num_connections)
+{
+	uint32_t i;
+	AUDIO_INSTANCE_T *instance;
+	VCOS_STATUS_T status;
+
+	LOG_DBG("%s: start", __func__);
+
+	if (num_connections > VCHI_MAX_NUM_CONNECTIONS) {
+		LOG_ERR("%s: unsupported number of connections %u (max=%u)",
+			__func__, num_connections, VCHI_MAX_NUM_CONNECTIONS);
+
+		return NULL;
+	}
+	// Allocate memory for this instance
+	instance = vcos_malloc(sizeof(*instance), "audio_instance");
+	memset(instance, 0, sizeof(*instance));
+
+	instance->num_connections = num_connections;
+	// Create the message available event
+	status =
+	    vcos_event_create(&instance->msg_avail_event, "audio_msg_avail");
+	if (status != VCOS_SUCCESS) {
+		LOG_ERR("%s: failed to create event (status=%d)", __func__,
+			status);
+
+		goto err_free_mem;
+	}
+	// Create a lock for exclusive, serialized VCHI connection access
+	status = vcos_mutex_create(&instance->vchi_mutex, "audio_vchi_mutex");
+	if (status != VCOS_SUCCESS) {
+		LOG_ERR("%s: failed to create event (status=%d)", __func__,
+			status);
+
+		goto err_delete_event;
+	}
+	// Open the VCHI service connections
+	for (i = 0; i < num_connections; i++) {
+		SERVICE_CREATION_T params = {
+			VC_AUDIO_SERVER_NAME,	// 4cc service code
+			vchi_connections[i],	// passed in fn pointers
+			0,	// rx fifo size (unused)
+			0,	// tx fifo size (unused)
+			audio_vchi_callback,	// service callback
+			instance,	// service callback parameter
+			VCOS_TRUE, //TODO: remove VCOS_FALSE,	// unaligned bulk recieves
+			VCOS_TRUE, //TODO: remove VCOS_FALSE,	// unaligned bulk transmits
+			VCOS_FALSE	// want crc check on bulk transfers
+		};
+
+		status = vchi_service_open(vchi_instance, &params,
+					   &instance->vchi_handle[i]);
+		if (status != VCOS_SUCCESS) {
+			LOG_ERR
+			    ("%s: failed to open VCHI service connection (status=%d)",
+			     __func__, status);
+
+			goto err_close_services;
+		}
+		// Finished with the service for now
+		vchi_service_release(instance->vchi_handle[i]);
+	}
+
+	return instance;
+
+err_close_services:
+	for (i = 0; i < instance->num_connections; i++) {
+		vchi_service_close(instance->vchi_handle[i]);
+	}
+
+	vcos_mutex_delete(&instance->vchi_mutex);
+
+err_delete_event:
+	vcos_event_delete(&instance->msg_avail_event);
+
+err_free_mem:
+	vcos_free(instance);
+
+	return NULL;
+}
+
+static int32_t vc_vchi_audio_deinit(AUDIO_INSTANCE_T *instance)
+{
+	uint32_t i;
+
+	audio_debug(" .. IN\n");
+
+	if (instance == NULL) {
+		LOG_ERR("%s: invalid handle %p", __func__, instance);
+
+		return -1;
+	}
+
+	audio_debug(" .. about to lock (%d)\n", instance->num_connections);
+	vcos_mutex_lock(&instance->vchi_mutex);
+
+	// Close all VCHI service connections
+	for (i = 0; i < instance->num_connections; i++) {
+		int32_t success;
+		audio_debug(" .. %i:closing %p\n", i, instance->vchi_handle[i]);
+		vchi_service_use(instance->vchi_handle[i]);
+
+		success = vchi_service_close(instance->vchi_handle[i]);
+		if (success != 0) {
+			LOG_ERR
+			    ("%s: failed to close VCHI service connection (status=%d)",
+			     __func__, success);
+		}
+	}
+
+	vcos_mutex_unlock(&instance->vchi_mutex);
+
+	vcos_mutex_delete(&instance->vchi_mutex);
+
+	vcos_event_delete(&instance->msg_avail_event);
+
+	vcos_free(instance);
+
+	// Unregister the log category so we can add it back next time
+	vcos_log_unregister(&audio_log_category);
+
+	audio_debug(" .. OUT\n");
+
+	return 0;
+}
+
+static int bcm2835_audio_open_connection(bcm2835_alsa_stream_t * alsa_stream)
+{
+	int ret = 0, err;
+	static VCHI_INSTANCE_T vchi_instance;
+	static VCHI_CONNECTION_T *vchi_connection;
+	AUDIO_INSTANCE_T *instance = alsa_stream->instance;
+	audio_debug(" .. IN\n");
+
+	LOG_INFO("%s: start", __func__);
+	//BUG_ON(instance);
+	if (instance) {
+		LOG_ERR("%s: VCHI instance already open (%p)",
+			__func__, instance);
+		//BUG_ON(atomic_read(&instance->callbacks_expected)-atomic_read(&instance->callbacks_received) < 0);
+		instance->alsa_stream = alsa_stream;
+		alsa_stream->instance = instance;
+		ret = 0; // xxx todo -1;
+		goto err_free_mem;
+	}
+
+	// Initialize and create a VCHI connection
+	ret = vchi_initialise(&vchi_instance);
+	if (ret != 0) {
+		LOG_ERR("%s: failed to initialise VCHI instance (ret=%d)",
+			__func__, ret);
+
+		ret = -EIO;
+		goto err_free_mem;
+	}
+	ret = vchi_connect(NULL, 0, vchi_instance);
+	if (ret != 0) {
+		LOG_ERR("%s: failed to connect VCHI instance (ret=%d)",
+			__func__, ret);
+
+		ret = -EIO;
+		goto err_free_mem;
+	}
+
+	// Set up the VCOS logging
+	vcos_log_set_level(VCOS_LOG_CATEGORY, LOG_LEVEL);
+	vcos_log_register("audio", VCOS_LOG_CATEGORY);
+
+
+	// Initialize an instance of the audio service
+	instance = vc_vchi_audio_init(vchi_instance, &vchi_connection, 1);
+
+	if (instance == NULL /*|| audio_handle != instance*/) {
+		LOG_ERR("%s: failed to initialize audio service",
+			__func__);
+
+		ret = -EPERM;
+		goto err_free_mem;
+	}
+
+	instance->alsa_stream = alsa_stream;
+	alsa_stream->instance = instance;
+
+
+	audio_debug(" success !\n");
+err_free_mem:
+	audio_debug(" .. OUT\n");
+
+	return ret;
+}
+
+int bcm2835_audio_open(bcm2835_alsa_stream_t * alsa_stream)
+{
+	AUDIO_INSTANCE_T *instance;
+	VC_AUDIO_MSG_T m;
+	int32_t success;
+	int ret;
+	audio_debug(" .. IN\n");
+
+	my_workqueue_init(alsa_stream);
+
+        ret = bcm2835_audio_open_connection(alsa_stream);
+	if (ret != 0) {
+		ret = -1;
+		goto exit;
+	}
+	instance = alsa_stream->instance;
+
+	vcos_mutex_lock(&instance->vchi_mutex);
+	vchi_service_use(instance->vchi_handle[0]);
+
+	m.type = VC_AUDIO_MSG_TYPE_OPEN;
+
+	// Send the message to the videocore
+	success = vchi_msg_queue(instance->vchi_handle[0],
+				 &m, sizeof m,
+				 VCHI_FLAGS_BLOCK_UNTIL_QUEUED, NULL);
+
+	if (success != 0) {
+		LOG_ERR("%s: failed on vchi_msg_queue (status=%d)",
+			__func__, success);
+
+		ret = -1;
+		goto unlock;
+	}
+
+	ret = 0;
+
+unlock:
+	vchi_service_release(instance->vchi_handle[0]);
+	vcos_mutex_unlock(&instance->vchi_mutex);
+exit:
+	audio_debug(" .. OUT\n");
+	return ret;
+}
+
+
+int bcm2835_audio_set_params(bcm2835_alsa_stream_t * alsa_stream,
+			     uint32_t channels, uint32_t samplerate,
+			     uint32_t bps)
+{
+	VC_AUDIO_MSG_T m;
+	AUDIO_INSTANCE_T *instance = alsa_stream->instance;
+	int32_t success;
+	uint32_t msg_len;
+	int ret;
+	audio_debug(" .. IN\n");
+
+	if (channels < 1 || channels > 2) {
+		audio_error(" channels (%d) not supported\n", channels);
+		return -EINVAL;
+	}
+
+	if (samplerate < 8000  || samplerate > 48000) {
+		audio_error(" samplerate (%d) not supported\n", samplerate);
+		return -EINVAL;
+	}
+
+	if (bps != 8 && bps != 16) {
+		audio_error(" Bits per sample (%d) not supported\n", bps);
+		return -EINVAL;
+	}
+
+	audio_info
+	    (" Setting ALSA channels(%d), samplerate(%d), bits-per-sample(%d)\n",
+	     channels, samplerate, bps);
+
+	vcos_mutex_lock(&instance->vchi_mutex);
+	vchi_service_use(instance->vchi_handle[0]);
+
+	instance->got_result = 0;
+	instance->result = -1;
+
+	m.type = VC_AUDIO_MSG_TYPE_CONFIG;
+	m.u.config.channels = channels;
+	m.u.config.samplerate = samplerate;
+	m.u.config.bps = bps;
+
+	// Send the message to the videocore
+	success = vchi_msg_queue(instance->vchi_handle[0],
+				 &m, sizeof m,
+				 VCHI_FLAGS_BLOCK_UNTIL_QUEUED, NULL);
+
+	if (success != 0) {
+		LOG_ERR("%s: failed on vchi_msg_queue (status=%d)",
+			__func__, success);
+
+		ret = -1;
+		goto unlock;
+	}
+
+	// We are expecting a reply from the videocore
+	while (!instance->got_result) {
+		success = vcos_event_wait(&instance->msg_avail_event);
+		if (success != VCOS_SUCCESS) {
+			LOG_ERR("%s: failed on waiting for event (status=%d)",
+				__func__, success);
+
+			ret = -1;
+			goto unlock;
+		}
+	}
+
+	if (instance->result != 0) {
+		LOG_ERR("%s: result=%d",
+			__func__, instance->result);
+
+		ret = -1;
+		goto unlock;
+	}
+
+	ret = 0;
+
+unlock:
+	vchi_service_release(instance->vchi_handle[0]);
+	vcos_mutex_unlock(&instance->vchi_mutex);
+
+	audio_debug(" .. OUT\n");
+	return ret;
+}
+
+int bcm2835_audio_setup(bcm2835_alsa_stream_t * alsa_stream)
+{
+	audio_debug(" .. IN\n");
+
+	audio_debug(" .. OUT\n");
+
+	return 0;
+}
+
+
+static int bcm2835_audio_start_worker(bcm2835_alsa_stream_t * alsa_stream)
+{
+	VC_AUDIO_MSG_T m;
+	AUDIO_INSTANCE_T *instance = alsa_stream->instance;
+	int32_t success;
+	int ret;
+	audio_debug(" .. IN\n");
+
+	vcos_mutex_lock(&instance->vchi_mutex);
+	vchi_service_use(instance->vchi_handle[0]);
+
+	m.type = VC_AUDIO_MSG_TYPE_START;
+
+	// Send the message to the videocore
+	success = vchi_msg_queue(instance->vchi_handle[0],
+				 &m, sizeof m,
+				 VCHI_FLAGS_BLOCK_UNTIL_QUEUED, NULL);
+
+	if (success != 0) {
+		LOG_ERR("%s: failed on vchi_msg_queue (status=%d)",
+			__func__, success);
+
+		ret = -1;
+		goto unlock;
+	}
+
+	ret = 0;
+
+unlock:
+	vchi_service_release(instance->vchi_handle[0]);
+	vcos_mutex_unlock(&instance->vchi_mutex);
+	audio_debug(" .. OUT\n");
+	return ret;
+}
+
+
+static int bcm2835_audio_stop_worker(bcm2835_alsa_stream_t * alsa_stream)
+{
+	VC_AUDIO_MSG_T m;
+	AUDIO_INSTANCE_T *instance = alsa_stream->instance;
+	int32_t success;
+	int ret;
+	audio_debug(" .. IN\n");
+
+	vcos_mutex_lock(&instance->vchi_mutex);
+	vchi_service_use(instance->vchi_handle[0]);
+
+	m.type = VC_AUDIO_MSG_TYPE_STOP;
+	m.u.stop.draining = alsa_stream->draining;
+
+	// Send the message to the videocore
+	success = vchi_msg_queue(instance->vchi_handle[0],
+				 &m, sizeof m,
+				 VCHI_FLAGS_BLOCK_UNTIL_QUEUED, NULL);
+
+	if (success != 0) {
+		LOG_ERR("%s: failed on vchi_msg_queue (status=%d)",
+			__func__, success);
+
+		ret = -1;
+		goto unlock;
+	}
+
+	ret = 0;
+
+unlock:
+	vchi_service_release(instance->vchi_handle[0]);
+	vcos_mutex_unlock(&instance->vchi_mutex);
+	audio_debug(" .. OUT\n");
+	return ret;
+}
+
+int bcm2835_audio_close(bcm2835_alsa_stream_t * alsa_stream)
+{
+	VC_AUDIO_MSG_T m;
+	AUDIO_INSTANCE_T *instance = alsa_stream->instance;
+	int32_t success;
+	int ret;
+	audio_debug(" .. IN outstanding_completes=%d\n", atomic_read(&instance->callbacks_expected)-atomic_read(&instance->callbacks_received));
+
+	my_workqueue_quit(alsa_stream);
+
+	vcos_mutex_lock(&instance->vchi_mutex);
+	vchi_service_use(instance->vchi_handle[0]);
+
+	m.type = VC_AUDIO_MSG_TYPE_CLOSE;
+	instance->got_result = 0;
+	// Send the message to the videocore
+	success = vchi_msg_queue(instance->vchi_handle[0],
+				 &m, sizeof m,
+				 VCHI_FLAGS_BLOCK_UNTIL_QUEUED, NULL);
+
+	if (success != 0) {
+		LOG_ERR("%s: failed on vchi_msg_queue (status=%d)",
+			__func__, success);
+
+		ret = -1;
+		goto unlock;
+	}
+	while (!instance->got_result /*|| atomic_read(&instance->callbacks_expected)-atomic_read(&instance->callbacks_received) < 0*/ ) {
+		success = vcos_event_wait(&instance->msg_avail_event);
+		if (success != VCOS_SUCCESS) {
+			LOG_ERR("%s: failed on waiting for event (status=%d)",
+				__func__, success);
+
+			ret = -1;
+			goto unlock;
+		}
+	}
+	if (instance->result != 0) {
+		LOG_ERR("%s: failed result (status=%d)",
+			__func__, instance->result);
+
+		ret = -1;
+		goto unlock;
+	}
+
+	ret = 0;
+
+unlock:
+	vchi_service_release(instance->vchi_handle[0]);
+	vcos_mutex_unlock(&instance->vchi_mutex);
+
+	// Stop the audio service
+	if (instance) {
+		vc_vchi_audio_deinit(instance);
+		alsa_stream->instance = NULL;
+	}
+	audio_debug(" .. OUT\n");
+	return ret;
+}
+
+static int bcm2835_audio_set_ctls_chan(bcm2835_alsa_stream_t *alsa_stream, bcm2835_chip_t *chip)
+{
+	VC_AUDIO_MSG_T m;
+	AUDIO_INSTANCE_T *instance = alsa_stream->instance;
+	int32_t success;
+	uint32_t msg_len;
+	int ret;
+	audio_debug(" .. IN\n");
+
+	audio_info
+	    (" Setting ALSA dest(%d), volume(%d)\n", chip->dest, chip->volume);
+
+	vcos_mutex_lock(&instance->vchi_mutex);
+	vchi_service_use(instance->vchi_handle[0]);
+
+	instance->got_result = 0;
+	instance->result = -1;
+
+	m.type = VC_AUDIO_MSG_TYPE_CONTROL;
+	m.u.control.dest = chip->dest;
+	m.u.control.volume = chip->volume;
+
+	// Send the message to the videocore
+	success = vchi_msg_queue(instance->vchi_handle[0],
+				 &m, sizeof m,
+				 VCHI_FLAGS_BLOCK_UNTIL_QUEUED, NULL);
+
+	if (success != 0) {
+		LOG_ERR("%s: failed on vchi_msg_queue (status=%d)",
+			__func__, success);
+
+		ret = -1;
+		goto unlock;
+	}
+
+	// We are expecting a reply from the videocore
+	while (!instance->got_result) {
+		success = vcos_event_wait(&instance->msg_avail_event);
+		if (success != VCOS_SUCCESS) {
+			LOG_ERR("%s: failed on waiting for event (status=%d)",
+				__func__, success);
+
+			ret = -1;
+			goto unlock;
+		}
+	}
+
+	if (instance->result != 0) {
+		LOG_ERR("%s: result=%d",
+			__func__, instance->result);
+
+		ret = -1;
+		goto unlock;
+	}
+
+	ret = 0;
+
+unlock:
+	vchi_service_release(instance->vchi_handle[0]);
+	vcos_mutex_unlock(&instance->vchi_mutex);
+
+	audio_debug(" .. OUT\n");
+	return ret;
+}
+
+
+int bcm2835_audio_set_ctls(bcm2835_chip_t *chip)
+{
+	int i;
+	int ret = 0;
+	audio_debug(" .. IN\n");
+
+	/* change ctls for all substreams */
+	for (i = 0; i < MAX_SUBSTREAMS; i++) {
+		if (chip->avail_substreams & (1 << i)) {
+			if (!chip->alsa_stream[i])
+				ret = -1;			
+			else if (bcm2835_audio_set_ctls_chan(chip->alsa_stream[i], chip) != 0)
+				ret = -1;			
+		}
+	}
+	audio_debug(" .. OUT ret=%d\n", ret);
+	return ret;
+}
+
+int bcm2835_audio_write(bcm2835_alsa_stream_t * alsa_stream, uint32_t count,
+			void *src)
+{
+	VC_AUDIO_MSG_T m;
+	AUDIO_INSTANCE_T *instance = alsa_stream->instance;
+	int32_t success;
+	int ret;
+
+	audio_debug(" .. IN outstanding=%d\n", atomic_read(&instance->callbacks_expected)-atomic_read(&instance->callbacks_received));
+
+	audio_info
+	    (" Writing %d bytes from %p\n", count, src);
+
+	vcos_mutex_lock(&instance->vchi_mutex);
+	vchi_service_use(instance->vchi_handle[0]);
+
+	m.type = VC_AUDIO_MSG_TYPE_WRITE;
+	m.u.write.count = count;
+	m.u.write.callback = alsa_stream->fifo_irq_handler;
+	m.u.write.cookie = alsa_stream;
+	m.u.write.silence = src == NULL;
+
+	atomic_add(1, &instance->callbacks_expected);
+	// Send the message to the videocore
+	success = vchi_msg_queue(instance->vchi_handle[0],
+				 &m, sizeof m,
+				 VCHI_FLAGS_BLOCK_UNTIL_QUEUED, NULL);
+
+	if (success != 0) {
+		LOG_ERR("%s: failed on vchi_msg_queue (status=%d)",
+			__func__, success);
+
+		ret = -1;
+		goto unlock;
+	}
+        audio_debug(" ... send header\n");
+
+	// Send the message to the videocore
+	success = vchi_bulk_queue_transmit(instance->vchi_handle[0],
+				 src, count, 0*VCHI_FLAGS_BLOCK_UNTIL_QUEUED + 1*VCHI_FLAGS_BLOCK_UNTIL_DATA_READ, NULL);
+	if (success != 0) {
+		LOG_ERR("%s: failed on vchi_msg_queue (status=%d)",
+			__func__, success);
+
+		ret = -1;
+		goto unlock;
+	}
+	ret = 0;
+
+unlock:
+	if (ret != 0) {
+		atomic_dec(&instance->callbacks_expected);
+	}
+	vchi_service_release(instance->vchi_handle[0]);
+	vcos_mutex_unlock(&instance->vchi_mutex);
+	audio_debug(" .. OUT\n");
+	return ret;
+}
+
+/**
+  * Returns all buffers from arm->vc
+  */
+void bcm2835_audio_flush_buffers(bcm2835_alsa_stream_t * alsa_stream)
+{
+	audio_debug(" .. IN\n");
+	audio_debug(" .. OUT\n");
+	return;
+}
+
+/**
+  * Forces VC to flush(drop) its filled playback buffers and 
+  * return them the us. (VC->ARM)
+  */
+void bcm2835_audio_flush_playback_buffers(bcm2835_alsa_stream_t * alsa_stream)
+{
+	audio_debug(" .. IN\n");
+	audio_debug(" .. OUT\n");
+}
+
+uint32_t bcm2835_audio_retrieve_buffers(bcm2835_alsa_stream_t *alsa_stream)
+{
+	uint32_t count = atomic_read(&alsa_stream->retrieved);
+	atomic_sub(count, &alsa_stream->retrieved);
+	return count;
+}
+
diff --git a/sound/arm/bcm2835.c b/sound/arm/bcm2835.c
new file mode 100755
index 0000000..54b06a3
--- /dev/null
+++ b/sound/arm/bcm2835.c
@@ -0,0 +1,426 @@
+/*****************************************************************************
+* Copyright 2011 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*	
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+#include <linux/platform_device.h>
+
+#include <linux/init.h>
+#include <linux/slab.h>
+
+#include "bcm2835.h"
+
+/* module parameters (see "Module Parameters") */
+/* SNDRV_CARDS: maximum number of cards supported by this module */
+static int index[MAX_SUBSTREAMS] = { [0 ... (MAX_SUBSTREAMS - 1)] = -1};
+static char *id[MAX_SUBSTREAMS] = { [0 ... (MAX_SUBSTREAMS - 1)] = NULL};
+static int enable[MAX_SUBSTREAMS] = { [0 ... (MAX_SUBSTREAMS - 1)] = 1 };
+
+/* HACKY global pointers needed for successive probes to work : ssp
+ * But compared against the changes we will have to do in VC audio_ipc code
+ * to export 8 audio_ipc devices as a single IPC device and then monitor all
+ * four devices in a thread, this gets things done quickly and should be easier
+ * to debug if we run into issues
+ */
+
+static struct snd_card *g_card = NULL;
+static bcm2835_chip_t *g_chip = NULL;
+
+static int snd_bcm2835_free(bcm2835_chip_t *chip)
+{
+	kfree(chip);
+	return 0;
+}
+
+
+/* component-destructor
+ * (see "Management of Cards and Components")
+ */
+static int snd_bcm2835_dev_free(struct snd_device *device)
+{
+	return snd_bcm2835_free(device->device_data);
+}
+
+
+/* chip-specific constructor
+ * (see "Management of Cards and Components")
+ */
+static int __devinit snd_bcm2835_create(struct snd_card *card,
+        struct platform_device *pdev,
+        bcm2835_chip_t **rchip)
+{
+	bcm2835_chip_t *chip;
+	int err;
+	static struct snd_device_ops ops = {
+		.dev_free = snd_bcm2835_dev_free,
+	};
+
+	*rchip = NULL;
+
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
+	if (chip == NULL)
+		return -ENOMEM;
+
+	chip->card = card;
+
+	err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);
+	if (err < 0) {
+		snd_bcm2835_free(chip);
+		return err;
+	}
+
+	*rchip = chip;
+	return 0;
+}
+
+static int __devinit snd_bcm2835_alsa_probe(struct platform_device *pdev)
+{
+	static int dev;
+	bcm2835_chip_t *chip;
+	struct snd_card *card;
+	int err;
+	printk(KERN_INFO"### snd_bcm2835_alsa_probe %p ###", pdev);
+
+	printk("############ PROBING FOR bcm2835 ALSA device (%d):(%d) ###############\n", dev, enable[dev]);
+
+	if (dev >= MAX_SUBSTREAMS)
+		return -ENODEV;
+
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	if (dev > 0)
+		goto add_register_map;
+
+	printk("Creating card...\n");
+	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &g_card);
+	if (err < 0)
+		goto out;
+
+	snd_card_set_dev(g_card, &pdev->dev);
+	strcpy(g_card->driver, "BRCM bcm2835 ALSA Driver");
+	strcpy(g_card->shortname, "bcm2835 ALSA");
+	sprintf(g_card->longname, "%s", g_card->shortname);
+
+	printk("Creating device/chip ..\n");
+	err = snd_bcm2835_create(g_card, pdev, &chip);
+	if (err < 0) {
+		printk(KERN_ERR"Failed to create bcm2835 chip\n");
+		goto out_bcm2835_create;
+	}
+
+	g_chip = chip;
+	err = snd_bcm2835_new_pcm(chip);
+	if (err < 0) {
+		printk(KERN_ERR"Failed to create new BCM2835 pcm device\n");
+		goto out_bcm2835_new_pcm;
+	}
+
+	printk("Adding controls ..\n");
+	err = snd_bcm2835_new_ctl(chip);
+	if (err < 0) {
+		printk(KERN_ERR"Failed to create new BCM2835 ctl\n");
+		goto out_bcm2835_new_ctl;
+	}
+
+add_register_map:
+	card = g_card;
+	chip = g_chip;
+
+	BUG_ON(!(card && chip));
+
+	chip->avail_substreams |= (1 << dev);
+	chip->pdev[dev] = pdev;
+
+	if (dev == 0) {
+		printk("Registering card ....\n");
+		err = snd_card_register(card);
+		if (err < 0) {
+			printk(KERN_ERR"Failed to register bcm2835 ALSA card \n");
+			goto out_card_register;
+		}
+		platform_set_drvdata(pdev, card);
+		printk("bcm2835 ALSA CARD CREATED!\n");
+	} else {
+		printk("bcm2835 ALSA CHIP CREATED!\n");
+		platform_set_drvdata(pdev, (void *)dev);
+	}
+
+	dev++;
+
+	return 0;
+
+out_card_register:
+out_bcm2835_new_ctl:
+out_bcm2835_new_pcm:
+out_bcm2835_create:
+	BUG_ON(!g_card);
+	if (snd_card_free(g_card))
+		printk(KERN_ERR"Failed to free Registered alsa card\n");
+	g_card = NULL;
+out:
+	dev = SNDRV_CARDS; /* stop more avail_substreams from being probed */
+	printk(KERN_ERR"BCM2835 ALSA Probe failed !!\n");
+	return err;
+}
+
+static int snd_bcm2835_alsa_remove(struct platform_device *pdev)
+{
+	uint32_t idx;
+	void *drv_data;
+
+	drv_data = platform_get_drvdata(pdev);
+
+	if (drv_data == (void *)g_card) {
+		/* This is the card device */
+		snd_card_free((struct snd_card *)drv_data);
+		g_card = NULL;
+		g_chip = NULL;
+	} else  {
+		idx = (uint32_t)drv_data;
+		if (g_card != NULL) {
+			BUG_ON(!g_chip);
+			/* We pass chip device numbers in audio ipc devices
+			 * other than the one we registered our card with
+			 */
+			idx = (uint32_t)drv_data;
+			BUG_ON(!idx || idx > MAX_SUBSTREAMS);
+			g_chip->avail_substreams &= ~(1 << idx);
+			/* There should be atleast one substream registered
+			 * after we are done here, as it wil be removed when
+			 * the *remove* is called for the card device
+			 */
+			BUG_ON(!g_chip->avail_substreams);
+		}
+	}
+
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int snd_bcm2835_alsa_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int snd_bcm2835_alsa_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+#endif
+
+static struct platform_driver bcm2835_alsa0_driver =
+{
+	.probe      = snd_bcm2835_alsa_probe,
+	.remove     = snd_bcm2835_alsa_remove,
+#ifdef CONFIG_PM
+	.suspend    = snd_bcm2835_alsa_suspend,
+	.resume     = snd_bcm2835_alsa_resume,
+#endif
+	.driver     = {
+		.name   = "bcm2835_AUD0",
+		.owner  = THIS_MODULE,
+	},
+};
+
+static struct platform_driver bcm2835_alsa1_driver =
+{
+	.probe      = snd_bcm2835_alsa_probe,
+	.remove     = snd_bcm2835_alsa_remove,
+#ifdef CONFIG_PM
+	.suspend    = snd_bcm2835_alsa_suspend,
+	.resume     = snd_bcm2835_alsa_resume,
+#endif
+	.driver     = {
+		.name   = "bcm2835_AUD1",
+		.owner  = THIS_MODULE,
+	},
+};
+
+static struct platform_driver bcm2835_alsa2_driver =
+{
+	.probe      = snd_bcm2835_alsa_probe,
+	.remove     = snd_bcm2835_alsa_remove,
+#ifdef CONFIG_PM
+	.suspend    = snd_bcm2835_alsa_suspend,
+	.resume     = snd_bcm2835_alsa_resume,
+#endif
+	.driver     = {
+		.name   = "bcm2835_AUD2",
+		.owner  = THIS_MODULE,
+	},
+};
+
+static struct platform_driver bcm2835_alsa3_driver =
+{
+	.probe      = snd_bcm2835_alsa_probe,
+	.remove     = snd_bcm2835_alsa_remove,
+#ifdef CONFIG_PM
+	.suspend    = snd_bcm2835_alsa_suspend,
+	.resume     = snd_bcm2835_alsa_resume,
+#endif
+	.driver     = {
+		.name   = "bcm2835_AUD3",
+		.owner  = THIS_MODULE,
+	},
+};
+
+static struct platform_driver bcm2835_alsa4_driver =
+{
+	.probe      = snd_bcm2835_alsa_probe,
+	.remove     = snd_bcm2835_alsa_remove,
+#ifdef CONFIG_PM
+	.suspend    = snd_bcm2835_alsa_suspend,
+	.resume     = snd_bcm2835_alsa_resume,
+#endif
+	.driver     = {
+		.name   = "bcm2835_AUD4",
+		.owner  = THIS_MODULE,
+	},
+};
+
+static struct platform_driver bcm2835_alsa5_driver =
+{
+	.probe      = snd_bcm2835_alsa_probe,
+	.remove     = snd_bcm2835_alsa_remove,
+#ifdef CONFIG_PM
+	.suspend    = snd_bcm2835_alsa_suspend,
+	.resume     = snd_bcm2835_alsa_resume,
+#endif
+	.driver     = {
+		.name   = "bcm2835_AUD5",
+		.owner  = THIS_MODULE,
+	},
+};
+
+static struct platform_driver bcm2835_alsa6_driver =
+{
+	.probe      = snd_bcm2835_alsa_probe,
+	.remove     = snd_bcm2835_alsa_remove,
+#ifdef CONFIG_PM
+	.suspend    = snd_bcm2835_alsa_suspend,
+	.resume     = snd_bcm2835_alsa_resume,
+#endif
+	.driver     = {
+		.name   = "bcm2835_AUD6",
+		.owner  = THIS_MODULE,
+	},
+};
+
+static struct platform_driver bcm2835_alsa7_driver =
+{
+	.probe      = snd_bcm2835_alsa_probe,
+	.remove     = snd_bcm2835_alsa_remove,
+#ifdef CONFIG_PM
+	.suspend    = snd_bcm2835_alsa_suspend,
+	.resume     = snd_bcm2835_alsa_resume,
+#endif
+	.driver     = {
+		.name   = "bcm2835_AUD7",
+		.owner  = THIS_MODULE,
+	},
+};
+
+
+static int __devinit bcm2835_alsa_device_init(void)
+{
+	int err;
+	err = platform_driver_register(&bcm2835_alsa0_driver);
+	if (err) {
+		printk("Error registering bcm2835_alsa0_driver %d .\n", err);
+		goto out;
+	}
+
+	err = platform_driver_register(&bcm2835_alsa1_driver);
+	if (err) {
+		printk("Error registering bcm2835_alsa1_driver %d .\n", err);
+		goto unregister_0;
+	}
+
+	err = platform_driver_register(&bcm2835_alsa2_driver);
+	if (err) {
+		printk("Error registering bcm2835_alsa2_driver %d .\n", err);
+		goto unregister_1;
+	}
+
+	err = platform_driver_register(&bcm2835_alsa3_driver);
+	if (err) {
+		printk("Error registering bcm2835_alsa3_driver %d .\n", err);
+		goto unregister_2;
+	}
+
+	err = platform_driver_register(&bcm2835_alsa4_driver);
+	if (err) {
+		printk("Error registering bcm2835_alsa4_driver %d .\n", err);
+		goto unregister_3;
+	}
+
+	err = platform_driver_register(&bcm2835_alsa5_driver);
+	if (err) {
+		printk("Error registering bcm2835_alsa5_driver %d .\n", err);
+		goto unregister_4;
+	}
+
+	err = platform_driver_register(&bcm2835_alsa6_driver);
+	if (err) {
+		printk("Error registering bcm2835_alsa6_driver %d .\n", err);
+		goto unregister_5;
+	}
+
+	err = platform_driver_register(&bcm2835_alsa7_driver);
+	if (err) {
+		printk("Error registering bcm2835_alsa7_driver %d .\n", err);
+		goto unregister_6;
+	}
+	printk(KERN_INFO"### BCM2835 ALSA driver init %s ### \n",err ? "FAILED": "OK");
+
+	return 0;
+
+unregister_6:
+	platform_driver_unregister(&bcm2835_alsa6_driver);
+unregister_5:
+	platform_driver_unregister(&bcm2835_alsa5_driver);
+unregister_4:
+	platform_driver_unregister(&bcm2835_alsa4_driver);
+unregister_3:
+	platform_driver_unregister(&bcm2835_alsa3_driver);
+unregister_2:
+	platform_driver_unregister(&bcm2835_alsa2_driver);
+unregister_1:
+	platform_driver_unregister(&bcm2835_alsa1_driver);
+unregister_0:
+	platform_driver_unregister(&bcm2835_alsa0_driver);
+out:
+	return err;
+}
+
+
+
+static void __devexit bcm2835_alsa_device_exit(void)
+{
+    platform_driver_unregister(&bcm2835_alsa0_driver);
+    platform_driver_unregister(&bcm2835_alsa1_driver);
+    platform_driver_unregister(&bcm2835_alsa2_driver);
+    platform_driver_unregister(&bcm2835_alsa3_driver);
+    platform_driver_unregister(&bcm2835_alsa4_driver);
+    platform_driver_unregister(&bcm2835_alsa5_driver);
+    platform_driver_unregister(&bcm2835_alsa6_driver);
+    platform_driver_unregister(&bcm2835_alsa7_driver);
+}
+
+late_initcall(bcm2835_alsa_device_init);
+module_exit(bcm2835_alsa_device_exit);
diff --git a/sound/arm/bcm2835.h b/sound/arm/bcm2835.h
new file mode 100755
index 0000000..d1d46ad
--- /dev/null
+++ b/sound/arm/bcm2835.h
@@ -0,0 +1,239 @@
+/*****************************************************************************
+* Copyright 2011 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*	
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+#ifndef __SOUND_ARM_BCM2835_H
+#define __SOUND_ARM_BCM2835_H 
+
+#define SUBSTREAM_NUM 1
+
+#include <linux/device.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <linux/workqueue.h>
+
+/* #define DUMP_RAW_DATA */
+#define AUDIO_DEBUG_ENABLE
+//#define AUDIO_VERBOSE_DEBUG_ENABLE
+
+/* Debug macros */
+#ifdef AUDIO_DEBUG_ENABLE
+
+#ifdef AUDIO_VERBOSE_DEBUG_ENABLE
+
+#define audio_debug(fmt, arg...)	\
+	printk(KERN_INFO"%s:%d " fmt, __func__, __LINE__, ##arg)
+
+#define audio_info(fmt, arg...)	\
+	printk(KERN_INFO"%s:%d " fmt, __func__, __LINE__, ##arg)
+
+#else
+
+#define audio_debug(fmt, arg...)	do {} while (0)
+
+#define audio_info(fmt, arg...)	        do {} while (0)
+
+#endif /* AUDIO_VERBOSE_DEBUG_ENABLE */
+
+#else
+
+#define audio_debug(fmt, arg...)	do {} while (0)
+
+#define audio_info(fmt, arg...)		do {} while (0)
+
+#endif /* AUDIO_DEBUG_ENABLE */
+
+#define audio_error(fmt, arg...)	\
+	printk(KERN_ERR"%s:%d " fmt, __func__, __LINE__, ##arg)
+
+#define audio_warning(fmt, arg...)	\
+	printk(KERN_WARNING"%s:%d " fmt, __func__, __LINE__, ##arg)
+
+#define audio_alert(fmt, arg...)	\
+	printk(KERN_ALERT"%s:%d " fmt, __func__, __LINE__, ##arg)
+
+#define MAX_SUBSTREAMS			(8)
+#define AVAIL_SUBSTREAMS_MASK		(0xff)
+
+#define AUDIO_IPC_BLOCK_NUM_BUFFERS    (8)
+#define AUDIO_IPC_BLOCK_BUFFER_SIZE    (1024*8)
+
+#define AUDIO_CONTROL_OFFSET			(0x00)
+	#define CTRL_EN_SHIFT			(0)
+	#define CTRL_EN_MASK			(0x00000001)
+	#define CTRL_PLAY_SHIFT			(1)
+	#define CTRL_PLAY_MASK			(0x00000002)
+	#define CTRL_MUTE_SHIFT			(2)
+	#define CTRL_MUTE_MASK			(0x00000004)
+	#define CTRL_SETUP_SHIFT		(3)
+	#define CTRL_SETUP_MASK			(0x00000008)
+	#define CTRL_FLUSH_SHIFT	    (4)
+	#define CTRL_FLUSH_MASK			(0x00000010)
+    #define CTRL_STOPMODE_SHIFT	    (5)
+	#define CTRL_STOPMODE_MASK		(0x00000020)
+
+#define AUDIO_STATUS_OFFSET			(0x04)
+	#define STAT_EN_SHIFT			(0)
+	#define STAT_EN_MASK			(0x00000001)
+	#define STAT_PLAY_SHIFT			(1)
+	#define STAT_PLAY_MASK			(0x00000002)
+	#define STAT_MUTE_SHIFT			(2)
+	#define STAT_MUTE_MASK			(0x00000004)
+	#define STAT_SETUP_SHIFT		(3)
+	#define STAT_SETUP_MASK			(0x00000008)
+	#define STAT_FLUSH_SHIFT	    (4)
+	#define STAT_FLUSH_MASK			(0x00000010)
+	#define STAT_STOPMODE_SHIFT	    (5)
+	#define STAT_STOPMODE_MASK		(0x00000020)
+
+/* Interrupt status */
+#define AUDIO_INTSTAT_OFFSET			(0x08)
+	#define INTSTAT_CONTROL_SHIFT		(0)
+	#define INTSTAT_CONTROL_MASK		(0x0000000f)
+	#define INTSTAT_FIFO_SHIFT		(4)
+	#define INTSTAT_FIFO_MASK		(0x000000f0)
+
+/* Configuration */
+#define AUDIO_DESTINATION_OFFSET		(0x0C)
+#define AUDIO_SAMPLE_RATE_OFFSET		(0x10)
+#define AUDIO_BIT_RATE_OFFSET			(0x14)
+#define AUDIO_VOLUME_OFFSET			(0x18)
+#define AUDIO_CHANNELS_OFFSET			(0x1C)
+
+/* Implemention of peterson's algorithm for shared memory semaphores */
+#define AUDIO_FLAG0_OFFSET			(0x20)
+#define AUDIO_FLAG1_OFFSET			(0x24)
+#define AUDIO_TURN_OFFSET			(0x28)
+
+/* Fifo registers */
+#define AUDIO_IN_WRITE_PTR_OFFSET		(0x30)
+#define AUDIO_IN_READ_PTR_OFFSET		(0x34)
+#define AUDIO_IN_FIFO_SIZE_OFFSET		(0x38)
+#define AUDIO_IN_FIFO_ENTRY_OFFSET		(0x3C)
+#define AUDIO_IN_FIFO_START_OFFSET		(0x40)
+
+/* 8 entries here of 4 words each = 0x80 gap from 0x50 */
+#define AUDIO_IN_FIFO_OFFSET			(0x50)
+
+#define AUDIO_OUT_WRITE_PTR_OFFSET		(0xD0)
+#define AUDIO_OUT_READ_PTR_OFFSET		(0xD4)
+#define AUDIO_OUT_FIFO_SIZE_OFFSET		(0xD8)
+#define AUDIO_OUT_FIFO_ENTRY_OFFSET		(0xDC)
+#define AUDIO_OUT_FIFO_START_OFFSET		(0xE0)
+
+/* 8 entries here of 4 words each = 0x80 gap from 0xF0 */
+#define AUDIO_OUT_FIFO_OFFSET			(0xF0)
+
+
+/* Some constants for values .. */
+typedef enum {
+	AUDIO_DEST_LOCAL = 0,
+	AUDIO_DEST_HDMI	= 2,
+	AUDIO_DEST_ALL = 3,
+} SND_BCM2835_ROUTE_T;
+
+typedef enum {
+	PCM_PLAYBACK_VOLUME,
+	PCM_PLAYBACK_MUTE,
+	PCM_PLAYBACK_DEVICE,
+} SND_BCM2835_CTRL_T;
+
+/* this struct is tightly packed - its size is 16bytes */
+typedef struct
+{
+	uint32_t buffer_id;
+	uint32_t buffer_size;
+	uint32_t buffer_ptr;
+	uint32_t spare;
+
+} AUDIO_FIFO_ENTRY_T;
+
+/* definition of the chip-specific record */
+typedef struct bcm2835_chip {
+	struct snd_card *card;
+	struct snd_pcm *pcm;
+	/* Bitmat for valid reg_base and irq numbers */
+	uint32_t avail_substreams;
+	struct platform_device *pdev[MAX_SUBSTREAMS];
+	struct bcm2835_alsa_stream *alsa_stream[MAX_SUBSTREAMS];
+
+	int volume;
+	int dest;
+	int mute;
+} bcm2835_chip_t;
+
+typedef struct bcm2835_audio_buffer {
+	uint32_t buffer_id;
+	phys_addr_t	bus_addr;
+	uint8_t __iomem	*start;
+	uint32_t size;
+	uint32_t data_left;
+	struct list_head link;
+
+} bcm2835_audio_buffer_t; 
+
+typedef struct bcm2835_alsa_stream {
+	bcm2835_chip_t *chip;
+	struct snd_pcm_substream *substream;
+
+	struct semaphore buffers_update_sem;
+	struct semaphore control_sem;
+	spinlock_t lock;
+	volatile uint32_t control;
+	volatile uint32_t status;
+
+	int open;
+	int running;
+	int draining;
+
+#ifdef DUMP_RAW_DATA
+	/* for debug */
+	int file;
+#endif
+	unsigned int pos;
+	unsigned int buffer_size;
+	unsigned int period_size;
+
+	uint32_t enable_fifo_irq;
+	irq_handler_t fifo_irq_handler;
+
+	atomic_t retrieved;
+	struct opaque_AUDIO_INSTANCE_T *instance;
+	struct workqueue_struct *my_wq;
+} bcm2835_alsa_stream_t;
+
+int snd_bcm2835_new_ctl(bcm2835_chip_t *chip);
+int snd_bcm2835_new_pcm(bcm2835_chip_t *chip);
+
+void bcm2835_audio_fifo_get_lock(bcm2835_alsa_stream_t *alsa_stream);
+void bcm2835_audio_fifo_put_lock(bcm2835_alsa_stream_t *alsa_stream);
+
+int bcm2835_audio_open(bcm2835_alsa_stream_t *alsa_stream);
+int bcm2835_audio_close(bcm2835_alsa_stream_t *alsa_stream);
+int bcm2835_audio_set_params(bcm2835_alsa_stream_t *alsa_stream, uint32_t channels, uint32_t samplerate, uint32_t bps);
+int bcm2835_audio_setup(bcm2835_alsa_stream_t *alsa_stream);
+int bcm2835_audio_start(bcm2835_alsa_stream_t *alsa_stream);
+int bcm2835_audio_stop(bcm2835_alsa_stream_t *alsa_stream);
+int bcm2835_audio_set_ctls(bcm2835_chip_t *chip);
+int bcm2835_audio_write(bcm2835_alsa_stream_t *alsa_stream, uint32_t count, void *src);
+//uint32_t bcm2835_audio_buffers_consumed_bytes(bcm2835_alsa_stream_t *alsa_stream);
+uint32_t bcm2835_audio_retrieve_buffers(bcm2835_alsa_stream_t *alsa_stream);
+void bcm2835_audio_flush_buffers(bcm2835_alsa_stream_t *alsa_stream);
+void bcm2835_audio_flush_playback_buffers(bcm2835_alsa_stream_t *alsa_stream);
+
+#endif /* __SOUND_ARM_BCM2835_H */
diff --git a/sound/arm/vc_vchi_audioserv_defs.h b/sound/arm/vc_vchi_audioserv_defs.h
new file mode 100644
index 0000000..3f41ff9
--- /dev/null
+++ b/sound/arm/vc_vchi_audioserv_defs.h
@@ -0,0 +1,128 @@
+/*****************************************************************************
+* Copyright 2011 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+#ifndef _VC_AUDIO_DEFS_H_
+#define _VC_AUDIO_DEFS_H_
+
+// FourCC code used for VCHI connection
+#define VC_AUDIO_SERVER_NAME  MAKE_FOURCC("AUDS")
+
+// Maximum message length
+#define VC_AUDIO_MAX_MSG_LEN  (sizeof( VC_AUDIO_MSG_T ))
+
+// List of screens that are currently supported
+// All message types supported for HOST->VC direction
+typedef enum
+{
+   VC_AUDIO_MSG_TYPE_RESULT,              // Generic result
+   VC_AUDIO_MSG_TYPE_COMPLETE,              // Generic result
+   VC_AUDIO_MSG_TYPE_CONFIG,                 // Configure audio
+   VC_AUDIO_MSG_TYPE_CONTROL,                 // Configure audio
+   VC_AUDIO_MSG_TYPE_OPEN,                 // Configure audio
+   VC_AUDIO_MSG_TYPE_CLOSE,                 // Configure audio
+   VC_AUDIO_MSG_TYPE_START,                 // Configure audio
+   VC_AUDIO_MSG_TYPE_STOP,                 // Configure audio
+   VC_AUDIO_MSG_TYPE_WRITE,                 // Configure audio
+   VC_AUDIO_MSG_TYPE_MAX
+
+} VC_AUDIO_MSG_TYPE;
+
+
+// configure the audio
+typedef struct
+{
+   uint32_t channels;
+   uint32_t samplerate;
+   uint32_t bps;
+
+} VC_AUDIO_CONFIG_T;
+
+typedef struct
+{
+   uint32_t volume;
+   uint32_t dest;
+
+} VC_AUDIO_CONTROL_T;
+
+// audio
+typedef struct
+{
+   uint32_t dummy;
+
+} VC_AUDIO_OPEN_T;
+
+// audio
+typedef struct
+{
+   uint32_t dummy;
+
+} VC_AUDIO_CLOSE_T;
+// audio
+typedef struct
+{
+   uint32_t dummy;
+
+} VC_AUDIO_START_T;
+// audio
+typedef struct
+{
+   uint32_t draining;
+
+} VC_AUDIO_STOP_T;
+
+// configure the write audio samples
+typedef struct
+{
+   uint32_t count; // in bytes
+   void *callback;
+   void *cookie;
+   uint32_t silence;
+} VC_AUDIO_WRITE_T;
+
+// Generic result for a request (VC->HOST)
+typedef struct
+{
+   int32_t success;  // Success value
+
+} VC_AUDIO_RESULT_T;
+
+// Generic result for a request (VC->HOST)
+typedef struct
+{
+   int32_t count;  // Success value
+   void *callback;
+   void *cookie;
+} VC_AUDIO_COMPLETE_T;
+
+// Message header for all messages in HOST->VC direction
+typedef struct
+{
+   int32_t type;     // Message type (VC_AUDIO_MSG_TYPE)
+   union
+   {
+	VC_AUDIO_CONFIG_T    config;
+   VC_AUDIO_CONTROL_T   control;
+	VC_AUDIO_OPEN_T  open;
+	VC_AUDIO_CLOSE_T  close;
+	VC_AUDIO_START_T  start;
+	VC_AUDIO_STOP_T  stop;
+	VC_AUDIO_WRITE_T  write;
+	VC_AUDIO_RESULT_T result;
+	VC_AUDIO_COMPLETE_T complete;
+   } u;
+} VC_AUDIO_MSG_T;
+
+
+#endif // _VC_AUDIO_DEFS_H_
+

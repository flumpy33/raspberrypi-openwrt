From bb4f37a030b62b8c08791b694bf39262665ed665 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 28 Mar 2012 23:26:18 +0100
Subject: [PATCH] Enable sound kernel modules. Tidy formatting. Fix ctl dest
 setting


diff --git a/arch/arm/configs/bcmrpi_cutdown_defconfig b/arch/arm/configs/bcmrpi_cutdown_defconfig
index 74f2dc9..e519412 100644
--- a/arch/arm/configs/bcmrpi_cutdown_defconfig
+++ b/arch/arm/configs/bcmrpi_cutdown_defconfig
@@ -208,6 +208,26 @@ CONFIG_FRAMEBUFFER_CONSOLE=y
 CONFIG_LOGO=y
 # CONFIG_LOGO_LINUX_MONO is not set
 # CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_SOUND=y
+CONFIG_SND=m
+CONFIG_SND_SEQUENCER=m
+CONFIG_SND_SEQ_DUMMY=m
+CONFIG_SND_MIXER_OSS=m
+CONFIG_SND_PCM_OSS=m
+CONFIG_SND_SEQUENCER_OSS=y
+CONFIG_SND_HRTIMER=m
+CONFIG_SND_DUMMY=m
+CONFIG_SND_ALOOP=m
+CONFIG_SND_VIRMIDI=m
+CONFIG_SND_MTPAV=m
+CONFIG_SND_SERIAL_U16550=m
+CONFIG_SND_MPU401=m
+CONFIG_SND_BCM2835=m
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_USB_UA101=m
+CONFIG_SND_USB_CAIAQ=m
+CONFIG_SND_USB_6FIRE=m
+CONFIG_SOUND_PRIME=m
 CONFIG_HID_PID=y
 CONFIG_USB_HIDDEV=y
 CONFIG_HID_A4TECH=m
diff --git a/arch/arm/configs/bcmrpi_defconfig b/arch/arm/configs/bcmrpi_defconfig
index 339aabf..df947e5 100644
--- a/arch/arm/configs/bcmrpi_defconfig
+++ b/arch/arm/configs/bcmrpi_defconfig
@@ -225,6 +225,26 @@ CONFIG_FRAMEBUFFER_CONSOLE=y
 CONFIG_LOGO=y
 # CONFIG_LOGO_LINUX_MONO is not set
 # CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_SOUND=y
+CONFIG_SND=m
+CONFIG_SND_SEQUENCER=m
+CONFIG_SND_SEQ_DUMMY=m
+CONFIG_SND_MIXER_OSS=m
+CONFIG_SND_PCM_OSS=m
+CONFIG_SND_SEQUENCER_OSS=y
+CONFIG_SND_HRTIMER=m
+CONFIG_SND_DUMMY=m
+CONFIG_SND_ALOOP=m
+CONFIG_SND_VIRMIDI=m
+CONFIG_SND_MTPAV=m
+CONFIG_SND_SERIAL_U16550=m
+CONFIG_SND_MPU401=m
+CONFIG_SND_BCM2835=m
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_USB_UA101=m
+CONFIG_SND_USB_CAIAQ=m
+CONFIG_SND_USB_6FIRE=m
+CONFIG_SOUND_PRIME=m
 CONFIG_HID_PID=y
 CONFIG_USB_HIDDEV=y
 CONFIG_HID_A4TECH=m
diff --git a/sound/arm/bcm2835-ctl.c b/sound/arm/bcm2835-ctl.c
index 20a24b8..c0546e35 100755
--- a/sound/arm/bcm2835-ctl.c
+++ b/sound/arm/bcm2835-ctl.c
@@ -33,30 +33,31 @@
 
 #include "bcm2835.h"
 
-static int snd_bcm2835_ctl_info(struct snd_kcontrol * kcontrol,
-		struct snd_ctl_elem_info * uinfo)
+static int snd_bcm2835_ctl_info(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_info *uinfo)
 {
 	if (kcontrol->private_value == PCM_PLAYBACK_VOLUME) {
-		uinfo->type			= SNDRV_CTL_ELEM_TYPE_INTEGER;
-		uinfo->count			= 1;
-		uinfo->value.integer.min	= -10240;
-		uinfo->value.integer.max	= 2303;
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+		uinfo->count = 1;
+		uinfo->value.integer.min = -10240;
+		uinfo->value.integer.max = 2303;
 	} else if (kcontrol->private_value == PCM_PLAYBACK_MUTE) {
-		uinfo->type			= SNDRV_CTL_ELEM_TYPE_INTEGER;
-		uinfo->count			= 1;
-		uinfo->value.integer.min	= 0;
-		uinfo->value.integer.max	= 1;
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+		uinfo->count = 1;
+		uinfo->value.integer.min = 0;
+		uinfo->value.integer.max = 1;
 	} else if (kcontrol->private_value == PCM_PLAYBACK_DEVICE) {
-		uinfo->type			= SNDRV_CTL_ELEM_TYPE_INTEGER;
-		uinfo->count			= 1;
-		uinfo->value.integer.min	= AUDIO_DEST_LOCAL;
-		uinfo->value.integer.max	= AUDIO_DEST_ALL;
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+		uinfo->count = 1;
+		uinfo->value.integer.min = 0;
+		uinfo->value.integer.max = AUDIO_DEST_MAX-0;
 	}
 
 	return 0;
 }
 
-static int snd_bcm2835_ctl_get(struct snd_kcontrol * kcontrol, struct snd_ctl_elem_value * ucontrol)
+static int snd_bcm2835_ctl_get(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
 {
 	struct bcm2835_chip *chip = snd_kcontrol_chip(kcontrol);
 
@@ -72,7 +73,8 @@ static int snd_bcm2835_ctl_get(struct snd_kcontrol * kcontrol, struct snd_ctl_el
 	return 0;
 }
 
-static int snd_bcm2835_ctl_put(struct snd_kcontrol * kcontrol, struct snd_ctl_elem_value * ucontrol)
+static int snd_bcm2835_ctl_put(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
 {
 	struct bcm2835_chip *chip = snd_kcontrol_chip(kcontrol);
 	int changed = 0;
@@ -82,7 +84,8 @@ static int snd_bcm2835_ctl_put(struct snd_kcontrol * kcontrol, struct snd_ctl_el
 			chip->mute = 0;
 			changed = 1;
 		}
-		if (changed || (ucontrol->value.integer.value[0] != chip->volume)) {
+		if (changed
+		    || (ucontrol->value.integer.value[0] != chip->volume)) {
 			int atten;
 
 			chip->volume = ucontrol->value.integer.value[0];
@@ -92,21 +95,21 @@ static int snd_bcm2835_ctl_put(struct snd_kcontrol * kcontrol, struct snd_ctl_el
 		}
 
 	} else if (kcontrol->private_value == PCM_PLAYBACK_MUTE) {
-		// Not implemented
+		/* Not implemented */
 		if (ucontrol->value.integer.value[0] != chip->mute) {
 			chip->mute = ucontrol->value.integer.value[0];
 			changed = 0;
 		}
 	} else if (kcontrol->private_value == PCM_PLAYBACK_DEVICE) {
-		if (ucontrol->value.integer.value[0] != chip->dest && ucontrol->value.integer.value[0] != 1) {
-			chip->dest= ucontrol->value.integer.value[0];
+		if (ucontrol->value.integer.value[0] != chip->dest) {
+			chip->dest = ucontrol->value.integer.value[0];
 			changed = 1;
 		}
 	}
 
 	if (changed) {
 		if (bcm2835_audio_set_ctls(chip))
-			printk(KERN_ERR"Failed to set ALSA controls..\n");
+			printk(KERN_ERR "Failed to set ALSA controls..\n");
 	}
 
 	return changed;
@@ -114,53 +117,54 @@ static int snd_bcm2835_ctl_put(struct snd_kcontrol * kcontrol, struct snd_ctl_el
 
 static DECLARE_TLV_DB_SCALE(snd_bcm2835_db_scale, -10240, 1, 1);
 
-static struct snd_kcontrol_new snd_bcm2835_ctl[] __devinitdata =
-{
+static struct snd_kcontrol_new snd_bcm2835_ctl[] __devinitdata = {
 	{
-		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-		.name  = "PCM Playback Volume",
-		.index = 0,
-		.access= SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE,
-		.private_value = PCM_PLAYBACK_VOLUME,
-		.info  = snd_bcm2835_ctl_info,
-		.get   = snd_bcm2835_ctl_get,
-		.put   = snd_bcm2835_ctl_put,
-		.count = 1,
-		.tlv = { .p = snd_bcm2835_db_scale }
-	},
+	 .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	 .name = "PCM Playback Volume",
+	 .index = 0,
+	 .access =
+	 SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE,
+	 .private_value = PCM_PLAYBACK_VOLUME,
+	 .info = snd_bcm2835_ctl_info,
+	 .get = snd_bcm2835_ctl_get,
+	 .put = snd_bcm2835_ctl_put,
+	 .count = 1,
+	 .tlv = {.p = snd_bcm2835_db_scale}
+	 },
 	{
-		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-		.name  = "PCM Playback Switch",
-		.index = 0,
-		.access= SNDRV_CTL_ELEM_ACCESS_READWRITE,
-		.private_value = PCM_PLAYBACK_MUTE,
-		.info  = snd_bcm2835_ctl_info,
-		.get   = snd_bcm2835_ctl_get,
-		.put   = snd_bcm2835_ctl_put,
-		.count = 1,
-	},
+	 .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	 .name = "PCM Playback Switch",
+	 .index = 0,
+	 .access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+	 .private_value = PCM_PLAYBACK_MUTE,
+	 .info = snd_bcm2835_ctl_info,
+	 .get = snd_bcm2835_ctl_get,
+	 .put = snd_bcm2835_ctl_put,
+	 .count = 1,
+	 },
 	{
-		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-		.name  = "PCM Playback Route",
-		.index = 0,
-		.access= SNDRV_CTL_ELEM_ACCESS_READWRITE,
-		.private_value = PCM_PLAYBACK_DEVICE,
-		.info  = snd_bcm2835_ctl_info,
-		.get   = snd_bcm2835_ctl_get,
-		.put   = snd_bcm2835_ctl_put,
-		.count = 1,
-	},
+	 .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	 .name = "PCM Playback Route",
+	 .index = 0,
+	 .access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+	 .private_value = PCM_PLAYBACK_DEVICE,
+	 .info = snd_bcm2835_ctl_info,
+	 .get = snd_bcm2835_ctl_get,
+	 .put = snd_bcm2835_ctl_put,
+	 .count = 1,
+	 },
 };
 
-int __devinit snd_bcm2835_new_ctl(bcm2835_chip_t *chip)
+int __devinit snd_bcm2835_new_ctl(bcm2835_chip_t * chip)
 {
 	int err;
 	unsigned int idx;
 
 	strcpy(chip->card->mixername, "Broadcom Mixer");
-	for (idx = 0; idx < ARRAY_SIZE(snd_bcm2835_ctl); idx++)
-	{
-		err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_bcm2835_ctl[idx], chip));
+	for (idx = 0; idx < ARRAY_SIZE(snd_bcm2835_ctl); idx++) {
+		err =
+		    snd_ctl_add(chip->card,
+				snd_ctl_new1(&snd_bcm2835_ctl[idx], chip));
 		if (err < 0)
 			return err;
 	}
diff --git a/sound/arm/bcm2835-pcm.c b/sound/arm/bcm2835-pcm.c
index 8adacc8..22bdb18 100755
--- a/sound/arm/bcm2835-pcm.c
+++ b/sound/arm/bcm2835-pcm.c
@@ -19,22 +19,20 @@
 
 /* hardware definition */
 static struct snd_pcm_hardware snd_bcm2835_playback_hw = {
-	.info = ( SNDRV_PCM_INFO_INTERLEAVED |
-		SNDRV_PCM_INFO_BLOCK_TRANSFER ),
-	.formats =          SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,
-	.rates =            SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
-	.rate_min =         8000,
-	.rate_max =         48000,
-	.channels_min =     1,
-	.channels_max =     2,
-	.buffer_bytes_max = (4*8-1)*1024, /* Needs to be less than audioplay buffer size */
-	.period_bytes_min = 1*1024,
-	.period_bytes_max = (4*8-1)*1024,
-	.periods_min =      1,
-	.periods_max =      4*8-1,
+	.info = (SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER),
+	.formats = SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,
+	.rates = SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
+	.rate_min = 8000,
+	.rate_max = 48000,
+	.channels_min = 1,
+	.channels_max = 2,
+	.buffer_bytes_max = (4 * 8 - 1) * 1024,	/* Needs to be less than audioplay buffer size */
+	.period_bytes_min = 1 * 1024,
+	.period_bytes_max = (4 * 8 - 1) * 1024,
+	.periods_min = 1,
+	.periods_max = 4 * 8 - 1,
 };
 
-
 static void snd_bcm2835_playback_free(struct snd_pcm_runtime *runtime)
 {
 	audio_info("Freeing up alsa stream here ..\n");
@@ -45,13 +43,14 @@ static void snd_bcm2835_playback_free(struct snd_pcm_runtime *runtime)
 
 static irqreturn_t bcm2835_playback_fifo_irq(int irq, void *dev_id)
 {
-	bcm2835_alsa_stream_t *alsa_stream = (bcm2835_alsa_stream_t *)dev_id;
+	bcm2835_alsa_stream_t *alsa_stream = (bcm2835_alsa_stream_t *) dev_id;
 	uint32_t consumed = 0;
 	int new_period = 0;
 
 	audio_debug(" .. IN\n");
 
-	audio_info("alsa_stream=%p substream=%p\n", alsa_stream, alsa_stream ? alsa_stream->substream:0);
+	audio_info("alsa_stream=%p substream=%p\n", alsa_stream,
+		   alsa_stream ? alsa_stream->substream : 0);
 
 	if (alsa_stream->open)
 		consumed = bcm2835_audio_retrieve_buffers(alsa_stream);
@@ -61,15 +60,18 @@ static irqreturn_t bcm2835_playback_fifo_irq(int irq, void *dev_id)
 	 */
 
 	if (alsa_stream->period_size) {
-		if ((alsa_stream->pos / alsa_stream->period_size) != ((alsa_stream->pos+consumed) / alsa_stream->period_size))
+		if ((alsa_stream->pos / alsa_stream->period_size) !=
+		    ((alsa_stream->pos + consumed) / alsa_stream->period_size))
 			new_period = 1;
 	}
-	audio_warning("updating pos cur: %d + %d max:%d new_period:%d\n", alsa_stream->pos,
-			(consumed /** AUDIO_IPC_BLOCK_BUFFER_SIZE*/), alsa_stream->buffer_size, new_period);
+	audio_warning("updating pos cur: %d + %d max:%d new_period:%d\n",
+		      alsa_stream->pos,
+		      (consumed /** AUDIO_IPC_BLOCK_BUFFER_SIZE*/ ),
+		      alsa_stream->buffer_size, new_period);
 	if (alsa_stream->buffer_size) {
 		alsa_stream->pos += consumed;
 		alsa_stream->pos %= alsa_stream->buffer_size;
-    	}
+	}
 	if (alsa_stream->substream) {
 		if (new_period)
 			snd_pcm_period_elapsed(alsa_stream->substream);
@@ -96,7 +98,9 @@ static int snd_bcm2835_playback_open(struct snd_pcm_substream *substream)
 	idx = substream->number;
 
 	if (idx > MAX_SUBSTREAMS) {
-		audio_error("substream(%d) device doesn't exist max(%d) substreams allowed\n", idx, MAX_SUBSTREAMS);
+		audio_error
+		    ("substream(%d) device doesn't exist max(%d) substreams allowed\n",
+		     idx, MAX_SUBSTREAMS);
 		err = -ENODEV;
 		goto out;
 	}
@@ -117,6 +121,7 @@ static int snd_bcm2835_playback_open(struct snd_pcm_substream *substream)
 	/* Initialise alsa_stream */
 	alsa_stream->chip = chip;
 	alsa_stream->substream = substream;
+	alsa_stream->idx = idx;
 	chip->alsa_stream[idx] = alsa_stream;
 
 	sema_init(&alsa_stream->buffers_update_sem, 0);
@@ -132,7 +137,8 @@ static int snd_bcm2835_playback_open(struct snd_pcm_substream *substream)
 	runtime->hw = snd_bcm2835_playback_hw;
 
 	/* minimum 16 bytes alignment (for vchiq bulk transfers) */
-	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 16);
+	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
+				   16);
 
 	err = bcm2835_audio_open(alsa_stream);
 	if (err != 0) {
@@ -179,7 +185,8 @@ static int snd_bcm2835_playback_close(struct snd_pcm_substream *substream)
 		alsa_stream->open = 0;
 		bcm2835_audio_close(alsa_stream);
 	}
-
+	if (alsa_stream->chip)
+		alsa_stream->chip->alsa_stream[alsa_stream->idx] = NULL;
 	/*
 	 * Do not free up alsa_stream here, it will be freed up by
 	 * runtime->private_free callback we registered in *_open above
@@ -192,23 +199,26 @@ static int snd_bcm2835_playback_close(struct snd_pcm_substream *substream)
 
 /* hw_params callback */
 static int snd_bcm2835_pcm_hw_params(struct snd_pcm_substream *substream,
-		struct snd_pcm_hw_params *params)
+				     struct snd_pcm_hw_params *params)
 {
 	int err;
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	bcm2835_alsa_stream_t *alsa_stream = (bcm2835_alsa_stream_t *)runtime->private_data;
+	bcm2835_alsa_stream_t *alsa_stream =
+	    (bcm2835_alsa_stream_t *) runtime->private_data;
 
 	audio_debug(" .. IN\n");
 
-	err = snd_pcm_lib_malloc_pages(substream,
-			params_buffer_bytes(params));
+	err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
 	if (err < 0) {
-		audio_error(" pcm_lib_malloc failed to allocated pages for buffers\n");
+		audio_error
+		    (" pcm_lib_malloc failed to allocated pages for buffers\n");
 		return err;
 	}
 
 	err = bcm2835_audio_set_params(alsa_stream, params_channels(params),
-			params_rate(params), snd_pcm_format_width(params_format(params)));
+				       params_rate(params),
+				       snd_pcm_format_width(params_format
+							    (params)));
 	if (err < 0) {
 		audio_error(" error setting hw params\n");
 	}
@@ -238,7 +248,9 @@ static int snd_bcm2835_pcm_prepare(struct snd_pcm_substream *substream)
 	alsa_stream->period_size = snd_pcm_lib_period_bytes(substream);
 	alsa_stream->pos = 0;
 
-	audio_warning("buffer_size=%d, period_size=%d pos=%d frame_bits=%d\n", alsa_stream->buffer_size, alsa_stream->period_size, alsa_stream->pos, runtime->frame_bits);
+	audio_warning("buffer_size=%d, period_size=%d pos=%d frame_bits=%d\n",
+		      alsa_stream->buffer_size, alsa_stream->period_size,
+		      alsa_stream->pos, runtime->frame_bits);
 
 	audio_debug(" .. OUT\n");
 	return 0;
@@ -254,38 +266,38 @@ static int snd_bcm2835_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 	audio_debug(" .. IN\n");
 
 	switch (cmd) {
-		case SNDRV_PCM_TRIGGER_START:
-			audio_warning("bcm2835_AUDIO_TRIGGER_START running=%d\n", alsa_stream->running);
-			if (!alsa_stream->running) {
-				err = bcm2835_audio_start(alsa_stream);
-				if (err == 0)
-				{
-					alsa_stream->running = 1;
-					alsa_stream->draining = 1;
-				}
-			}
-			break;
-		case SNDRV_PCM_TRIGGER_STOP:
-			audio_warning("bcm2835_AUDIO_TRIGGER_STOP running=%d draining=%d\n", runtime->status->state==SNDRV_PCM_STATE_DRAINING, alsa_stream->running);
-			if (runtime->status->state==SNDRV_PCM_STATE_DRAINING)
-			{
-				audio_info("DRAINING\n");
+	case SNDRV_PCM_TRIGGER_START:
+		audio_warning("bcm2835_AUDIO_TRIGGER_START running=%d\n",
+			      alsa_stream->running);
+		if (!alsa_stream->running) {
+			err = bcm2835_audio_start(alsa_stream);
+			if (err == 0) {
+				alsa_stream->running = 1;
 				alsa_stream->draining = 1;
 			}
-                        else
-                        {
-                                audio_info("DROPPING\n");
-                                alsa_stream->draining=0;
-                        }
-			if (alsa_stream->running) {
-				err = bcm2835_audio_stop(alsa_stream);
-				if (err != 0)
-					audio_error(" Failed to STOP alsa device\n");
-				alsa_stream->running = 0;
-			}
-			break;
-		default:
-			err = -EINVAL;
+		}
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		audio_warning
+		    ("bcm2835_AUDIO_TRIGGER_STOP running=%d draining=%d\n",
+		     runtime->status->state == SNDRV_PCM_STATE_DRAINING,
+		     alsa_stream->running);
+		if (runtime->status->state == SNDRV_PCM_STATE_DRAINING) {
+			audio_info("DRAINING\n");
+			alsa_stream->draining = 1;
+		} else {
+			audio_info("DROPPING\n");
+			alsa_stream->draining = 0;
+		}
+		if (alsa_stream->running) {
+			err = bcm2835_audio_stop(alsa_stream);
+			if (err != 0)
+				audio_error(" Failed to STOP alsa device\n");
+			alsa_stream->running = 0;
+		}
+		break;
+	default:
+		err = -EINVAL;
 	}
 
 	audio_debug(" .. OUT\n");
@@ -302,77 +314,98 @@ snd_bcm2835_pcm_pointer(struct snd_pcm_substream *substream)
 	audio_debug(" .. IN\n");
 
 	audio_warning("pcm_pointer... (%d) hwptr=%d appl=%d pos=%d\n", 0,
-		frames_to_bytes(runtime, runtime->status->hw_ptr), frames_to_bytes(runtime, runtime->control->appl_ptr), alsa_stream->pos);
+		      frames_to_bytes(runtime, runtime->status->hw_ptr),
+		      frames_to_bytes(runtime, runtime->control->appl_ptr),
+		      alsa_stream->pos);
 
 	audio_debug(" .. OUT\n");
 	return bytes_to_frames(runtime, alsa_stream->pos);
 }
 
-static int snd_bcm2835_pcm_copy(struct snd_pcm_substream *substream, int channel,
-		snd_pcm_uframes_t pos, void *src, snd_pcm_uframes_t count)
+static int snd_bcm2835_pcm_copy(struct snd_pcm_substream *substream,
+				int channel, snd_pcm_uframes_t pos, void *src,
+				snd_pcm_uframes_t count)
 {
 	int ret;
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	bcm2835_alsa_stream_t *alsa_stream = runtime->private_data;
 
 	audio_debug(" .. IN\n");
-	audio_warning("copy.......... (%d) hwptr=%d appl=%d pos=%d\n", frames_to_bytes(runtime, count), 
-		frames_to_bytes(runtime, runtime->status->hw_ptr), frames_to_bytes(runtime, runtime->control->appl_ptr), alsa_stream->pos);
-	ret = bcm2835_audio_write(alsa_stream, frames_to_bytes(runtime, count), src);
+	audio_warning("copy.......... (%d) hwptr=%d appl=%d pos=%d\n",
+		      frames_to_bytes(runtime, count), frames_to_bytes(runtime,
+								       runtime->
+								       status->
+								       hw_ptr),
+		      frames_to_bytes(runtime, runtime->control->appl_ptr),
+		      alsa_stream->pos);
+	ret =
+	    bcm2835_audio_write(alsa_stream, frames_to_bytes(runtime, count),
+				src);
 	audio_debug(" .. OUT\n");
 	return ret;
 }
 
-static int snd_bcm2835_pcm_silence(struct snd_pcm_substream *substream, int channel,
-		snd_pcm_uframes_t post, snd_pcm_uframes_t count)
+static int snd_bcm2835_pcm_silence(struct snd_pcm_substream *substream,
+				   int channel, snd_pcm_uframes_t post,
+				   snd_pcm_uframes_t count)
 {
 	int ret;
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	bcm2835_alsa_stream_t *alsa_stream = runtime->private_data;
 
 	audio_debug(" .. IN\n");
-	audio_warning("silence....... (%d) hwptr=%d appl=%d pos=%d\n", frames_to_bytes(runtime, count),
-		frames_to_bytes(runtime, runtime->status->hw_ptr), frames_to_bytes(runtime, runtime->control->appl_ptr), alsa_stream->pos);
-	ret = bcm2835_audio_write(alsa_stream, frames_to_bytes(runtime, count), NULL);
+	audio_warning("silence....... (%d) hwptr=%d appl=%d pos=%d\n",
+		      frames_to_bytes(runtime, count), frames_to_bytes(runtime,
+								       runtime->
+								       status->
+								       hw_ptr),
+		      frames_to_bytes(runtime, runtime->control->appl_ptr),
+		      alsa_stream->pos);
+	ret =
+	    bcm2835_audio_write(alsa_stream, frames_to_bytes(runtime, count),
+				NULL);
 	audio_debug(" .. OUT\n");
 	return ret;
 }
 
-static int snd_bcm2835_pcm_lib_ioctl (	struct snd_pcm_substream * substream, unsigned int cmd, void * arg)
+static int snd_bcm2835_pcm_lib_ioctl(struct snd_pcm_substream *substream,
+				     unsigned int cmd, void *arg)
 {
 	int ret = snd_pcm_lib_ioctl(substream, cmd, arg);
-	audio_debug(" .. substream=%p, cmd=%d, arg=%p (%x) ret=%d\n", substream, cmd, arg, arg ? *(unsigned *)arg:0, ret);
+	audio_debug(" .. substream=%p, cmd=%d, arg=%p (%x) ret=%d\n", substream,
+		    cmd, arg, arg ? *(unsigned *)arg : 0, ret);
 	return ret;
 }
- 
+
 /* operators */
 static struct snd_pcm_ops snd_bcm2835_playback_ops = {
-	.open =        snd_bcm2835_playback_open,
-	.close =       snd_bcm2835_playback_close,
-	.ioctl =       snd_bcm2835_pcm_lib_ioctl,
-	.hw_params =   snd_bcm2835_pcm_hw_params,
-	.hw_free =     snd_bcm2835_pcm_hw_free,
-	.prepare =     snd_bcm2835_pcm_prepare,
-	.trigger =     snd_bcm2835_pcm_trigger,
-	.pointer =     snd_bcm2835_pcm_pointer,
-	.copy    =     snd_bcm2835_pcm_copy,
-	.silence =     snd_bcm2835_pcm_silence,
+	.open = snd_bcm2835_playback_open,
+	.close = snd_bcm2835_playback_close,
+	.ioctl = snd_bcm2835_pcm_lib_ioctl,
+	.hw_params = snd_bcm2835_pcm_hw_params,
+	.hw_free = snd_bcm2835_pcm_hw_free,
+	.prepare = snd_bcm2835_pcm_prepare,
+	.trigger = snd_bcm2835_pcm_trigger,
+	.pointer = snd_bcm2835_pcm_pointer,
+	.copy = snd_bcm2835_pcm_copy,
+	.silence = snd_bcm2835_pcm_silence,
 };
 
 /* create a pcm device */
-int __devinit snd_bcm2835_new_pcm(bcm2835_chip_t *chip)
+int __devinit snd_bcm2835_new_pcm(bcm2835_chip_t * chip)
 {
 	struct snd_pcm *pcm;
 	int err;
 
 	audio_debug(" .. IN\n");
-	err = snd_pcm_new(chip->card, "bcm2835 ALSA", 0, MAX_SUBSTREAMS, 0, &pcm);
-	if (err < 0) 
+	err =
+	    snd_pcm_new(chip->card, "bcm2835 ALSA", 0, MAX_SUBSTREAMS, 0, &pcm);
+	if (err < 0)
 		return err;
 	pcm->private_data = chip;
 	strcpy(pcm->name, "bcm2835 ALSA");
 	chip->pcm = pcm;
-	chip->dest = AUDIO_DEST_LOCAL;
+	chip->dest = AUDIO_DEST_AUTO;
 	chip->volume = 100;
 	/* set operators */
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
@@ -381,11 +414,11 @@ int __devinit snd_bcm2835_new_pcm(bcm2835_chip_t *chip)
 	/* pre-allocation of buffers */
 	/* NOTE: this may fail */
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,
-			snd_dma_continuous_data(GFP_KERNEL), 64*1024, 64*1024);
+					      snd_dma_continuous_data
+					      (GFP_KERNEL), 64 * 1024,
+					      64 * 1024);
 
 	audio_debug(" .. OUT\n");
 
 	return 0;
 }
-
-
diff --git a/sound/arm/bcm2835-vchiq.c b/sound/arm/bcm2835-vchiq.c
index cef8597..6620e57 100755
--- a/sound/arm/bcm2835-vchiq.c
+++ b/sound/arm/bcm2835-vchiq.c
@@ -29,27 +29,26 @@
 
 #include "bcm2835.h"
 
-
-// ---- Include Files --------------------------------------------------------
+/* ---- Include Files -------------------------------------------------------- */
 
 #include "interface/vchi/vchi.h"
 #include "interface/vcos/vcos.h"
 #include "interface/vcos/vcos_logging.h"
 #include "vc_vchi_audioserv_defs.h"
 
-// ---- Private Constants and Types ------------------------------------------
+/* ---- Private Constants and Types ------------------------------------------ */
 
-// VCOS logging category for this service
+/* VCOS logging category for this service */
 #define VCOS_LOG_CATEGORY (&audio_log_category)
 
-// Default VCOS logging level
+/* Default VCOS logging level */
 #define LOG_LEVEL  VCOS_LOG_TRACE
 
-// Logging macros (for remapping to other logging mechanisms, i.e., printf)
-#define LOG_ERR( fmt, arg... )   pr_err(fmt, ##arg) //vcos_log_error( fmt, ##arg )
-#define LOG_WARN( fmt, arg... )  pr_err(fmt, ##arg) //vcos_log_warn( fmt, ##arg )
-#define LOG_INFO( fmt, arg... )  pr_err(fmt, ##arg) //vcos_log_info( fmt, ##arg )
-#define LOG_DBG( fmt, arg... )   pr_err( fmt, ##arg )
+/* Logging macros (for remapping to other logging mechanisms, i.e., printf) */
+#define LOG_ERR( fmt, arg... )   vcos_log_error( "%s:%d " fmt, __func__, __LINE__, ##arg)
+#define LOG_WARN( fmt, arg... )  vcos_log_warn( "%s:%d " fmt, __func__, __LINE__, ##arg)
+#define LOG_INFO( fmt, arg... )  vcos_log_info( "%s:%d " fmt, __func__, __LINE__, ##arg)
+#define LOG_DBG( fmt, arg... )   vcos_log_info( "%s:%d " fmt, __func__, __LINE__, ##arg)
 
 typedef struct opaque_AUDIO_INSTANCE_T {
 	uint32_t num_connections;
@@ -58,176 +57,150 @@ typedef struct opaque_AUDIO_INSTANCE_T {
 	VCOS_MUTEX_T vchi_mutex;
 	bcm2835_alsa_stream_t *alsa_stream;
 	int32_t result, got_result;
-	atomic_t callbacks_expected, callbacks_received;
 } AUDIO_INSTANCE_T;
 
-// ---- Private Variables ----------------------------------------------------
+/* ---- Private Variables ---------------------------------------------------- */
 
-// VCOS logging category for this service
+/* VCOS logging category for this service */
 static VCOS_LOG_CAT_T audio_log_category;
 
-// ---- Private Function Prototypes ------------------------------------------
+/* ---- Private Function Prototypes ------------------------------------------ */
 
-// ---- Private Functions ----------------------------------------------------
+/* ---- Private Functions ---------------------------------------------------- */
 
 static int bcm2835_audio_stop_worker(bcm2835_alsa_stream_t * alsa_stream);
 static int bcm2835_audio_start_worker(bcm2835_alsa_stream_t * alsa_stream);
 
-#if 1
 typedef struct {
-  struct work_struct my_work;
-  bcm2835_alsa_stream_t *alsa_stream;
-  int    x;
+	struct work_struct my_work;
+	bcm2835_alsa_stream_t *alsa_stream;
+	int x;
 } my_work_t;
 
-static void my_wq_function( struct work_struct *work)
+static void my_wq_function(struct work_struct *work)
 {
-  my_work_t *w = (my_work_t *)work;
-  int ret=-9;
-  audio_debug(" .. IN %p:%d\n", w->alsa_stream, w->x);  
-  switch (w->x) {
-    case 1: ret=bcm2835_audio_start_worker(w->alsa_stream); break;
-    case 2: ret=bcm2835_audio_stop_worker(w->alsa_stream); break;
-    default:  audio_error(" Unexpected work: %p:%d\n", w->alsa_stream, w->x); break;
-  }
-  kfree( (void *)work );
-  audio_debug(" .. OUT %d\n", ret);  
+	my_work_t *w = (my_work_t *) work;
+	int ret = -9;
+	LOG_DBG(" .. IN %p:%d\n", w->alsa_stream, w->x);
+	switch (w->x) {
+	case 1:
+		ret = bcm2835_audio_start_worker(w->alsa_stream);
+		break;
+	case 2:
+		ret = bcm2835_audio_stop_worker(w->alsa_stream);
+		break;
+	default:
+		LOG_ERR(" Unexpected work: %p:%d\n", w->alsa_stream, w->x);
+		break;
+	}
+	kfree((void *)work);
+	LOG_DBG(" .. OUT %d\n", ret);
 }
 
-int bcm2835_audio_start(bcm2835_alsa_stream_t *alsa_stream)
+int bcm2835_audio_start(bcm2835_alsa_stream_t * alsa_stream)
 {
-  int ret = -1;
-  audio_debug(" .. IN\n");
-  if (alsa_stream->my_wq) {
-    my_work_t *work = kmalloc(sizeof(my_work_t), GFP_KERNEL);
-    /* Queue some work (item 1) */
-    if (work) {
-      INIT_WORK( (struct work_struct *)work, my_wq_function );
-      work->alsa_stream = alsa_stream;
-      work->x = 1;
-      if (queue_work( alsa_stream->my_wq, (struct work_struct *)work ))
-        ret = 0;
-    } else
-      audio_error(" .. Error: NULL work kmalloc\n"); 
-  }
-  audio_debug(" .. OUT %d\n", ret);  
-  return ret;
+	int ret = -1;
+	LOG_DBG(" .. IN\n");
+	if (alsa_stream->my_wq) {
+		my_work_t *work = kmalloc(sizeof(my_work_t), GFP_KERNEL);
+		/* Queue some work (item 1) */
+		if (work) {
+			INIT_WORK((struct work_struct *)work, my_wq_function);
+			work->alsa_stream = alsa_stream;
+			work->x = 1;
+			if (queue_work
+			    (alsa_stream->my_wq, (struct work_struct *)work))
+				ret = 0;
+		} else
+			LOG_ERR(" .. Error: NULL work kmalloc\n");
+	}
+	LOG_DBG(" .. OUT %d\n", ret);
+	return ret;
 }
 
 int bcm2835_audio_stop(bcm2835_alsa_stream_t * alsa_stream)
 {
-  int ret = -1;
-  audio_debug(" .. IN\n");
-  if (alsa_stream->my_wq) {
-    my_work_t *work = kmalloc(sizeof(my_work_t), GFP_KERNEL);
-    /* Queue some work (item 1) */
-    if (work) {
-      INIT_WORK( (struct work_struct *)work, my_wq_function );
-      work->alsa_stream = alsa_stream;
-      work->x = 2;
-      if (queue_work( alsa_stream->my_wq, (struct work_struct *)work ))
-        ret = 0;
-    } else
-      audio_error(" .. Error: NULL work kmalloc\n"); 
-  }
-  audio_debug(" .. OUT %d\n", ret);  
-  return ret;
+	int ret = -1;
+	LOG_DBG(" .. IN\n");
+	if (alsa_stream->my_wq) {
+		my_work_t *work = kmalloc(sizeof(my_work_t), GFP_KERNEL);
+		/* Queue some work (item 1) */
+		if (work) {
+			INIT_WORK((struct work_struct *)work, my_wq_function);
+			work->alsa_stream = alsa_stream;
+			work->x = 2;
+			if (queue_work
+			    (alsa_stream->my_wq, (struct work_struct *)work))
+				ret = 0;
+		} else
+			LOG_ERR(" .. Error: NULL work kmalloc\n");
+	}
+	LOG_DBG(" .. OUT %d\n", ret);
+	return ret;
 }
 
 void my_workqueue_init(bcm2835_alsa_stream_t * alsa_stream)
 {
-  alsa_stream->my_wq = create_workqueue("my_queue");
+	alsa_stream->my_wq = create_workqueue("my_queue");
 }
 
 void my_workqueue_quit(bcm2835_alsa_stream_t * alsa_stream)
 {
-  if (alsa_stream->my_wq) {
-    flush_workqueue( alsa_stream->my_wq );
-    destroy_workqueue( alsa_stream->my_wq );
-    alsa_stream->my_wq = NULL;
-  }
-}
-
-#else
-static void *my_tasklet_data;
-
-/* Bottom Half Function */
-void my_tasklet_function( unsigned long data )
-{
-	int err = 0;
-	bcm2835_alsa_stream_t *alsa_stream = (bcm2835_alsa_stream_t *)my_tasklet_data;
-	audio_info("IN ..(%d)\n", (int)data);
-	if (data)
-		err = bcm2835_audio_stop_worker(alsa_stream);
-	else
-		err = bcm2835_audio_start_worker(alsa_stream);
-	if (err != 0)
-		audio_error(" Failed to START/STOP alsa device\n");
-	audio_info("OUT ..\n");
-}
-
-DECLARE_TASKLET( my_tasklet_start, my_tasklet_function, 0);
-DECLARE_TASKLET( my_tasklet_stop, my_tasklet_function, 1);
-
-
-int bcm2835_audio_start(bcm2835_alsa_stream_t * alsa_stream)
-{
-				my_tasklet_data = alsa_stream;
-				  tasklet_schedule( &my_tasklet_stop );
-
-}
-int bcm2835_audio_stop(bcm2835_alsa_stream_t * alsa_stream)
-{
-				my_tasklet_data = alsa_stream;
-				  tasklet_schedule( &my_tasklet_start );
+	if (alsa_stream->my_wq) {
+		flush_workqueue(alsa_stream->my_wq);
+		destroy_workqueue(alsa_stream->my_wq);
+		alsa_stream->my_wq = NULL;
+	}
 }
-void my_workqueue_init(bcm2835_alsa_stream_t * alsa_stream){}
-void my_workqueue_quit(bcm2835_alsa_stream_t * alsa_stream){}
 
-#endif
 static void audio_vchi_callback(void *param,
 				const VCHI_CALLBACK_REASON_T reason,
 				void *msg_handle)
 {
-	AUDIO_INSTANCE_T *instance = (AUDIO_INSTANCE_T *)param;
+	AUDIO_INSTANCE_T *instance = (AUDIO_INSTANCE_T *) param;
 	int32_t status;
 	int32_t msg_len;
 	VC_AUDIO_MSG_T m;
 	bcm2835_alsa_stream_t *alsa_stream = 0;
-	audio_debug(" .. IN instance=%p, param=%p, reason=%d, handle=%p outstanding_completes=%d\n", instance, param, reason, msg_handle, atomic_read(&instance->callbacks_expected)-atomic_read(&instance->callbacks_received));
+	LOG_DBG(" .. IN instance=%p, param=%p, reason=%d, handle=%p\n",
+		instance, param, reason, msg_handle);
 
 	if (!instance || reason != VCHI_CALLBACK_MSG_AVAILABLE) {
 		return;
 	}
 	alsa_stream = instance->alsa_stream;
 	status = vchi_msg_dequeue(instance->vchi_handle[0],
-				   &m, sizeof m, &msg_len, VCHI_FLAGS_NONE);
+				  &m, sizeof m, &msg_len, VCHI_FLAGS_NONE);
 	if (m.type == VC_AUDIO_MSG_TYPE_RESULT) {
-		audio_debug(" .. instance=%p, m.type=VC_AUDIO_MSG_TYPE_RESULT, success=%d\n", instance, m.u.result.success);
+		LOG_DBG
+		    (" .. instance=%p, m.type=VC_AUDIO_MSG_TYPE_RESULT, success=%d\n",
+		     instance, m.u.result.success);
 		BUG_ON(instance->got_result);
 		instance->result = m.u.result.success;
 		instance->got_result = 1;
 		vcos_event_signal(&instance->msg_avail_event);
 	} else if (m.type == VC_AUDIO_MSG_TYPE_COMPLETE) {
-		irq_handler_t callback = (irq_handler_t)m.u.complete.callback;
-		audio_debug(" .. instance=%p, m.type=VC_AUDIO_MSG_TYPE_COMPLETE, complete=%d\n", instance, m.u.complete.count);
+		irq_handler_t callback = (irq_handler_t) m.u.complete.callback;
+		LOG_DBG
+		    (" .. instance=%p, m.type=VC_AUDIO_MSG_TYPE_COMPLETE, complete=%d\n",
+		     instance, m.u.complete.count);
 		if (alsa_stream && callback) {
 			atomic_add(m.u.complete.count, &alsa_stream->retrieved);
 			callback(0, alsa_stream);
 		} else {
-			audio_debug(" .. unexpected alsa_stream=%p, callback=%p\n", alsa_stream, callback);
+			LOG_DBG(" .. unexpected alsa_stream=%p, callback=%p\n",
+				alsa_stream, callback);
 		}
-		atomic_inc(&instance->callbacks_received);
-		//BUG_ON(atomic_read(&instance->callbacks_expected)-atomic_read(&instance->callbacks_received) < 0);
 		vcos_event_signal(&instance->msg_avail_event);
 	} else {
-		audio_debug(" .. unexpected m.type=%d\n", m.type);
+		LOG_DBG(" .. unexpected m.type=%d\n", m.type);
 	}
 }
 
 static AUDIO_INSTANCE_T *vc_vchi_audio_init(VCHI_INSTANCE_T vchi_instance,
-					  VCHI_CONNECTION_T ** vchi_connections,
-					  uint32_t num_connections)
+					    VCHI_CONNECTION_T **
+					    vchi_connections,
+					    uint32_t num_connections)
 {
 	uint32_t i;
 	AUDIO_INSTANCE_T *instance;
@@ -241,12 +214,12 @@ static AUDIO_INSTANCE_T *vc_vchi_audio_init(VCHI_INSTANCE_T vchi_instance,
 
 		return NULL;
 	}
-	// Allocate memory for this instance
+	/* Allocate memory for this instance */
 	instance = vcos_malloc(sizeof(*instance), "audio_instance");
 	memset(instance, 0, sizeof(*instance));
 
 	instance->num_connections = num_connections;
-	// Create the message available event
+	/* Create the message available event */
 	status =
 	    vcos_event_create(&instance->msg_avail_event, "audio_msg_avail");
 	if (status != VCOS_SUCCESS) {
@@ -255,7 +228,7 @@ static AUDIO_INSTANCE_T *vc_vchi_audio_init(VCHI_INSTANCE_T vchi_instance,
 
 		goto err_free_mem;
 	}
-	// Create a lock for exclusive, serialized VCHI connection access
+	/* Create a lock for exclusive, serialized VCHI connection access */
 	status = vcos_mutex_create(&instance->vchi_mutex, "audio_vchi_mutex");
 	if (status != VCOS_SUCCESS) {
 		LOG_ERR("%s: failed to create event (status=%d)", __func__,
@@ -263,7 +236,7 @@ static AUDIO_INSTANCE_T *vc_vchi_audio_init(VCHI_INSTANCE_T vchi_instance,
 
 		goto err_delete_event;
 	}
-	// Open the VCHI service connections
+	/* Open the VCHI service connections */
 	for (i = 0; i < num_connections; i++) {
 		SERVICE_CREATION_T params = {
 			VC_AUDIO_SERVER_NAME,	// 4cc service code
@@ -272,8 +245,8 @@ static AUDIO_INSTANCE_T *vc_vchi_audio_init(VCHI_INSTANCE_T vchi_instance,
 			0,	// tx fifo size (unused)
 			audio_vchi_callback,	// service callback
 			instance,	// service callback parameter
-			VCOS_TRUE, //TODO: remove VCOS_FALSE,	// unaligned bulk recieves
-			VCOS_TRUE, //TODO: remove VCOS_FALSE,	// unaligned bulk transmits
+			VCOS_TRUE,	//TODO: remove VCOS_FALSE,   // unaligned bulk recieves
+			VCOS_TRUE,	//TODO: remove VCOS_FALSE,   // unaligned bulk transmits
 			VCOS_FALSE	// want crc check on bulk transfers
 		};
 
@@ -286,7 +259,7 @@ static AUDIO_INSTANCE_T *vc_vchi_audio_init(VCHI_INSTANCE_T vchi_instance,
 
 			goto err_close_services;
 		}
-		// Finished with the service for now
+		/* Finished with the service for now */
 		vchi_service_release(instance->vchi_handle[i]);
 	}
 
@@ -308,11 +281,11 @@ err_free_mem:
 	return NULL;
 }
 
-static int32_t vc_vchi_audio_deinit(AUDIO_INSTANCE_T *instance)
+static int32_t vc_vchi_audio_deinit(AUDIO_INSTANCE_T * instance)
 {
 	uint32_t i;
 
-	audio_debug(" .. IN\n");
+	LOG_DBG(" .. IN\n");
 
 	if (instance == NULL) {
 		LOG_ERR("%s: invalid handle %p", __func__, instance);
@@ -320,13 +293,13 @@ static int32_t vc_vchi_audio_deinit(AUDIO_INSTANCE_T *instance)
 		return -1;
 	}
 
-	audio_debug(" .. about to lock (%d)\n", instance->num_connections);
+	LOG_DBG(" .. about to lock (%d)\n", instance->num_connections);
 	vcos_mutex_lock(&instance->vchi_mutex);
 
-	// Close all VCHI service connections
+	/* Close all VCHI service connections */
 	for (i = 0; i < instance->num_connections; i++) {
 		int32_t success;
-		audio_debug(" .. %i:closing %p\n", i, instance->vchi_handle[i]);
+		LOG_DBG(" .. %i:closing %p\n", i, instance->vchi_handle[i]);
 		vchi_service_use(instance->vchi_handle[i]);
 
 		success = vchi_service_close(instance->vchi_handle[i]);
@@ -345,35 +318,34 @@ static int32_t vc_vchi_audio_deinit(AUDIO_INSTANCE_T *instance)
 
 	vcos_free(instance);
 
-	// Unregister the log category so we can add it back next time
+	/* Unregister the log category so we can add it back next time */
 	vcos_log_unregister(&audio_log_category);
 
-	audio_debug(" .. OUT\n");
+	LOG_DBG(" .. OUT\n");
 
 	return 0;
 }
 
 static int bcm2835_audio_open_connection(bcm2835_alsa_stream_t * alsa_stream)
 {
-	int ret = 0, err;
 	static VCHI_INSTANCE_T vchi_instance;
 	static VCHI_CONNECTION_T *vchi_connection;
 	AUDIO_INSTANCE_T *instance = alsa_stream->instance;
-	audio_debug(" .. IN\n");
+	int ret;
+	LOG_DBG(" .. IN\n");
 
 	LOG_INFO("%s: start", __func__);
 	//BUG_ON(instance);
 	if (instance) {
 		LOG_ERR("%s: VCHI instance already open (%p)",
 			__func__, instance);
-		//BUG_ON(atomic_read(&instance->callbacks_expected)-atomic_read(&instance->callbacks_received) < 0);
 		instance->alsa_stream = alsa_stream;
 		alsa_stream->instance = instance;
-		ret = 0; // xxx todo -1;
+		ret = 0;	// xxx todo -1;
 		goto err_free_mem;
 	}
 
-	// Initialize and create a VCHI connection
+	/* Initialize and create a VCHI connection */
 	ret = vchi_initialise(&vchi_instance);
 	if (ret != 0) {
 		LOG_ERR("%s: failed to initialise VCHI instance (ret=%d)",
@@ -391,17 +363,15 @@ static int bcm2835_audio_open_connection(bcm2835_alsa_stream_t * alsa_stream)
 		goto err_free_mem;
 	}
 
-	// Set up the VCOS logging
+	/* Set up the VCOS logging */
 	vcos_log_set_level(VCOS_LOG_CATEGORY, LOG_LEVEL);
 	vcos_log_register("audio", VCOS_LOG_CATEGORY);
 
-
-	// Initialize an instance of the audio service
+	/* Initialize an instance of the audio service */
 	instance = vc_vchi_audio_init(vchi_instance, &vchi_connection, 1);
 
-	if (instance == NULL /*|| audio_handle != instance*/) {
-		LOG_ERR("%s: failed to initialize audio service",
-			__func__);
+	if (instance == NULL /*|| audio_handle != instance */ ) {
+		LOG_ERR("%s: failed to initialize audio service", __func__);
 
 		ret = -EPERM;
 		goto err_free_mem;
@@ -410,10 +380,9 @@ static int bcm2835_audio_open_connection(bcm2835_alsa_stream_t * alsa_stream)
 	instance->alsa_stream = alsa_stream;
 	alsa_stream->instance = instance;
 
-
-	audio_debug(" success !\n");
+	LOG_DBG(" success !\n");
 err_free_mem:
-	audio_debug(" .. OUT\n");
+	LOG_DBG(" .. OUT\n");
 
 	return ret;
 }
@@ -424,11 +393,11 @@ int bcm2835_audio_open(bcm2835_alsa_stream_t * alsa_stream)
 	VC_AUDIO_MSG_T m;
 	int32_t success;
 	int ret;
-	audio_debug(" .. IN\n");
+	LOG_DBG(" .. IN\n");
 
 	my_workqueue_init(alsa_stream);
 
-        ret = bcm2835_audio_open_connection(alsa_stream);
+	ret = bcm2835_audio_open_connection(alsa_stream);
 	if (ret != 0) {
 		ret = -1;
 		goto exit;
@@ -440,7 +409,7 @@ int bcm2835_audio_open(bcm2835_alsa_stream_t * alsa_stream)
 
 	m.type = VC_AUDIO_MSG_TYPE_OPEN;
 
-	// Send the message to the videocore
+	/* Send the message to the videocore */
 	success = vchi_msg_queue(instance->vchi_handle[0],
 				 &m, sizeof m,
 				 VCHI_FLAGS_BLOCK_UNTIL_QUEUED, NULL);
@@ -459,40 +428,21 @@ unlock:
 	vchi_service_release(instance->vchi_handle[0]);
 	vcos_mutex_unlock(&instance->vchi_mutex);
 exit:
-	audio_debug(" .. OUT\n");
+	LOG_DBG(" .. OUT\n");
 	return ret;
 }
 
-
-int bcm2835_audio_set_params(bcm2835_alsa_stream_t * alsa_stream,
-			     uint32_t channels, uint32_t samplerate,
-			     uint32_t bps)
+static int bcm2835_audio_set_ctls_chan(bcm2835_alsa_stream_t * alsa_stream,
+				       bcm2835_chip_t * chip)
 {
 	VC_AUDIO_MSG_T m;
 	AUDIO_INSTANCE_T *instance = alsa_stream->instance;
 	int32_t success;
-	uint32_t msg_len;
 	int ret;
-	audio_debug(" .. IN\n");
-
-	if (channels < 1 || channels > 2) {
-		audio_error(" channels (%d) not supported\n", channels);
-		return -EINVAL;
-	}
-
-	if (samplerate < 8000  || samplerate > 48000) {
-		audio_error(" samplerate (%d) not supported\n", samplerate);
-		return -EINVAL;
-	}
+	LOG_DBG(" .. IN\n");
 
-	if (bps != 8 && bps != 16) {
-		audio_error(" Bits per sample (%d) not supported\n", bps);
-		return -EINVAL;
-	}
-
-	audio_info
-	    (" Setting ALSA channels(%d), samplerate(%d), bits-per-sample(%d)\n",
-	     channels, samplerate, bps);
+	LOG_INFO
+	    (" Setting ALSA dest(%d), volume(%d)\n", chip->dest, chip->volume);
 
 	vcos_mutex_lock(&instance->vchi_mutex);
 	vchi_service_use(instance->vchi_handle[0]);
@@ -500,12 +450,11 @@ int bcm2835_audio_set_params(bcm2835_alsa_stream_t * alsa_stream,
 	instance->got_result = 0;
 	instance->result = -1;
 
-	m.type = VC_AUDIO_MSG_TYPE_CONFIG;
-	m.u.config.channels = channels;
-	m.u.config.samplerate = samplerate;
-	m.u.config.bps = bps;
+	m.type = VC_AUDIO_MSG_TYPE_CONTROL;
+	m.u.control.dest = chip->dest;
+	m.u.control.volume = chip->volume;
 
-	// Send the message to the videocore
+	/* Send the message to the videocore */
 	success = vchi_msg_queue(instance->vchi_handle[0],
 				 &m, sizeof m,
 				 VCHI_FLAGS_BLOCK_UNTIL_QUEUED, NULL);
@@ -518,7 +467,7 @@ int bcm2835_audio_set_params(bcm2835_alsa_stream_t * alsa_stream,
 		goto unlock;
 	}
 
-	// We are expecting a reply from the videocore
+	/* We are expecting a reply from the videocore */
 	while (!instance->got_result) {
 		success = vcos_event_wait(&instance->msg_avail_event);
 		if (success != VCOS_SUCCESS) {
@@ -531,8 +480,7 @@ int bcm2835_audio_set_params(bcm2835_alsa_stream_t * alsa_stream,
 	}
 
 	if (instance->result != 0) {
-		LOG_ERR("%s: result=%d",
-			__func__, instance->result);
+		LOG_ERR("%s: result=%d", __func__, instance->result);
 
 		ret = -1;
 		goto unlock;
@@ -544,34 +492,63 @@ unlock:
 	vchi_service_release(instance->vchi_handle[0]);
 	vcos_mutex_unlock(&instance->vchi_mutex);
 
-	audio_debug(" .. OUT\n");
+	LOG_DBG(" .. OUT\n");
 	return ret;
 }
 
-int bcm2835_audio_setup(bcm2835_alsa_stream_t * alsa_stream)
+int bcm2835_audio_set_ctls(bcm2835_chip_t * chip)
 {
-	audio_debug(" .. IN\n");
-
-	audio_debug(" .. OUT\n");
-
-	return 0;
+	int i;
+	int ret = 0;
+	LOG_DBG(" .. IN\n");
+printk(KERN_ERR "set_ctls dest=%d volume=%d\n", chip->dest, chip->volume);
+	/* change ctls for all substreams */
+	for (i = 0; i < MAX_SUBSTREAMS; i++) {
+		if (chip->avail_substreams & (1 << i)) {
+			if (!chip->alsa_stream[i])
+				ret = 0;
+			else if (bcm2835_audio_set_ctls_chan
+				 (chip->alsa_stream[i], chip) != 0)
+				ret = -1;
+		}
+	}
+	LOG_DBG(" .. OUT ret=%d\n", ret);
+	return ret;
 }
 
-
-static int bcm2835_audio_start_worker(bcm2835_alsa_stream_t * alsa_stream)
+int bcm2835_audio_set_params(bcm2835_alsa_stream_t * alsa_stream,
+			     uint32_t channels, uint32_t samplerate,
+			     uint32_t bps)
 {
 	VC_AUDIO_MSG_T m;
 	AUDIO_INSTANCE_T *instance = alsa_stream->instance;
 	int32_t success;
 	int ret;
-	audio_debug(" .. IN\n");
+	LOG_DBG(" .. IN\n");
+
+	LOG_INFO
+	    (" Setting ALSA channels(%d), samplerate(%d), bits-per-sample(%d)\n",
+	     channels, samplerate, bps);
+
+	/* resend ctls - alsa_stream may not have been open when first send */
+	ret = bcm2835_audio_set_ctls_chan(alsa_stream, alsa_stream->chip);
+	if (ret != 0) {
+		LOG_ERR(" Alsa controls not supported\n");
+		return -EINVAL;
+	}
 
 	vcos_mutex_lock(&instance->vchi_mutex);
 	vchi_service_use(instance->vchi_handle[0]);
 
-	m.type = VC_AUDIO_MSG_TYPE_START;
+	instance->got_result = 0;
+	instance->result = -1;
 
-	// Send the message to the videocore
+	m.type = VC_AUDIO_MSG_TYPE_CONFIG;
+	m.u.config.channels = channels;
+	m.u.config.samplerate = samplerate;
+	m.u.config.bps = bps;
+
+	/* Send the message to the videocore */
 	success = vchi_msg_queue(instance->vchi_handle[0],
 				 &m, sizeof m,
 				 VCHI_FLAGS_BLOCK_UNTIL_QUEUED, NULL);
@@ -584,31 +561,58 @@ static int bcm2835_audio_start_worker(bcm2835_alsa_stream_t * alsa_stream)
 		goto unlock;
 	}
 
+	/* We are expecting a reply from the videocore */
+	while (!instance->got_result) {
+		success = vcos_event_wait(&instance->msg_avail_event);
+		if (success != VCOS_SUCCESS) {
+			LOG_ERR("%s: failed on waiting for event (status=%d)",
+				__func__, success);
+
+			ret = -1;
+			goto unlock;
+		}
+	}
+
+	if (instance->result != 0) {
+		LOG_ERR("%s: result=%d", __func__, instance->result);
+
+		ret = -1;
+		goto unlock;
+	}
+
 	ret = 0;
 
 unlock:
 	vchi_service_release(instance->vchi_handle[0]);
 	vcos_mutex_unlock(&instance->vchi_mutex);
-	audio_debug(" .. OUT\n");
+
+	LOG_DBG(" .. OUT\n");
 	return ret;
 }
 
+int bcm2835_audio_setup(bcm2835_alsa_stream_t * alsa_stream)
+{
+	LOG_DBG(" .. IN\n");
+
+	LOG_DBG(" .. OUT\n");
 
-static int bcm2835_audio_stop_worker(bcm2835_alsa_stream_t * alsa_stream)
+	return 0;
+}
+
+static int bcm2835_audio_start_worker(bcm2835_alsa_stream_t * alsa_stream)
 {
 	VC_AUDIO_MSG_T m;
 	AUDIO_INSTANCE_T *instance = alsa_stream->instance;
 	int32_t success;
 	int ret;
-	audio_debug(" .. IN\n");
+	LOG_DBG(" .. IN\n");
 
 	vcos_mutex_lock(&instance->vchi_mutex);
 	vchi_service_use(instance->vchi_handle[0]);
 
-	m.type = VC_AUDIO_MSG_TYPE_STOP;
-	m.u.stop.draining = alsa_stream->draining;
+	m.type = VC_AUDIO_MSG_TYPE_START;
 
-	// Send the message to the videocore
+	/* Send the message to the videocore */
 	success = vchi_msg_queue(instance->vchi_handle[0],
 				 &m, sizeof m,
 				 VCHI_FLAGS_BLOCK_UNTIL_QUEUED, NULL);
@@ -626,26 +630,25 @@ static int bcm2835_audio_stop_worker(bcm2835_alsa_stream_t * alsa_stream)
 unlock:
 	vchi_service_release(instance->vchi_handle[0]);
 	vcos_mutex_unlock(&instance->vchi_mutex);
-	audio_debug(" .. OUT\n");
+	LOG_DBG(" .. OUT\n");
 	return ret;
 }
 
-int bcm2835_audio_close(bcm2835_alsa_stream_t * alsa_stream)
+static int bcm2835_audio_stop_worker(bcm2835_alsa_stream_t * alsa_stream)
 {
 	VC_AUDIO_MSG_T m;
 	AUDIO_INSTANCE_T *instance = alsa_stream->instance;
 	int32_t success;
 	int ret;
-	audio_debug(" .. IN outstanding_completes=%d\n", atomic_read(&instance->callbacks_expected)-atomic_read(&instance->callbacks_received));
-
-	my_workqueue_quit(alsa_stream);
+	LOG_DBG(" .. IN\n");
 
 	vcos_mutex_lock(&instance->vchi_mutex);
 	vchi_service_use(instance->vchi_handle[0]);
 
-	m.type = VC_AUDIO_MSG_TYPE_CLOSE;
-	instance->got_result = 0;
-	// Send the message to the videocore
+	m.type = VC_AUDIO_MSG_TYPE_STOP;
+	m.u.stop.draining = alsa_stream->draining;
+
+	/* Send the message to the videocore */
 	success = vchi_msg_queue(instance->vchi_handle[0],
 				 &m, sizeof m,
 				 VCHI_FLAGS_BLOCK_UNTIL_QUEUED, NULL);
@@ -657,62 +660,32 @@ int bcm2835_audio_close(bcm2835_alsa_stream_t * alsa_stream)
 		ret = -1;
 		goto unlock;
 	}
-	while (!instance->got_result /*|| atomic_read(&instance->callbacks_expected)-atomic_read(&instance->callbacks_received) < 0*/ ) {
-		success = vcos_event_wait(&instance->msg_avail_event);
-		if (success != VCOS_SUCCESS) {
-			LOG_ERR("%s: failed on waiting for event (status=%d)",
-				__func__, success);
-
-			ret = -1;
-			goto unlock;
-		}
-	}
-	if (instance->result != 0) {
-		LOG_ERR("%s: failed result (status=%d)",
-			__func__, instance->result);
-
-		ret = -1;
-		goto unlock;
-	}
 
 	ret = 0;
 
 unlock:
 	vchi_service_release(instance->vchi_handle[0]);
 	vcos_mutex_unlock(&instance->vchi_mutex);
-
-	// Stop the audio service
-	if (instance) {
-		vc_vchi_audio_deinit(instance);
-		alsa_stream->instance = NULL;
-	}
-	audio_debug(" .. OUT\n");
+	LOG_DBG(" .. OUT\n");
 	return ret;
 }
 
-static int bcm2835_audio_set_ctls_chan(bcm2835_alsa_stream_t *alsa_stream, bcm2835_chip_t *chip)
+int bcm2835_audio_close(bcm2835_alsa_stream_t * alsa_stream)
 {
 	VC_AUDIO_MSG_T m;
 	AUDIO_INSTANCE_T *instance = alsa_stream->instance;
 	int32_t success;
-	uint32_t msg_len;
 	int ret;
-	audio_debug(" .. IN\n");
+	LOG_DBG(" .. IN\n");
 
-	audio_info
-	    (" Setting ALSA dest(%d), volume(%d)\n", chip->dest, chip->volume);
+	my_workqueue_quit(alsa_stream);
 
 	vcos_mutex_lock(&instance->vchi_mutex);
 	vchi_service_use(instance->vchi_handle[0]);
 
+	m.type = VC_AUDIO_MSG_TYPE_CLOSE;
 	instance->got_result = 0;
-	instance->result = -1;
-
-	m.type = VC_AUDIO_MSG_TYPE_CONTROL;
-	m.u.control.dest = chip->dest;
-	m.u.control.volume = chip->volume;
-
-	// Send the message to the videocore
+	/* Send the message to the videocore */
 	success = vchi_msg_queue(instance->vchi_handle[0],
 				 &m, sizeof m,
 				 VCHI_FLAGS_BLOCK_UNTIL_QUEUED, NULL);
@@ -720,12 +693,9 @@ static int bcm2835_audio_set_ctls_chan(bcm2835_alsa_stream_t *alsa_stream, bcm28
 	if (success != 0) {
 		LOG_ERR("%s: failed on vchi_msg_queue (status=%d)",
 			__func__, success);
-
 		ret = -1;
 		goto unlock;
 	}
-
-	// We are expecting a reply from the videocore
 	while (!instance->got_result) {
 		success = vcos_event_wait(&instance->msg_avail_event);
 		if (success != VCOS_SUCCESS) {
@@ -736,9 +706,8 @@ static int bcm2835_audio_set_ctls_chan(bcm2835_alsa_stream_t *alsa_stream, bcm28
 			goto unlock;
 		}
 	}
-
 	if (instance->result != 0) {
-		LOG_ERR("%s: result=%d",
+		LOG_ERR("%s: failed result (status=%d)",
 			__func__, instance->result);
 
 		ret = -1;
@@ -751,27 +720,12 @@ unlock:
 	vchi_service_release(instance->vchi_handle[0]);
 	vcos_mutex_unlock(&instance->vchi_mutex);
 
-	audio_debug(" .. OUT\n");
-	return ret;
-}
-
-
-int bcm2835_audio_set_ctls(bcm2835_chip_t *chip)
-{
-	int i;
-	int ret = 0;
-	audio_debug(" .. IN\n");
-
-	/* change ctls for all substreams */
-	for (i = 0; i < MAX_SUBSTREAMS; i++) {
-		if (chip->avail_substreams & (1 << i)) {
-			if (!chip->alsa_stream[i])
-				ret = -1;			
-			else if (bcm2835_audio_set_ctls_chan(chip->alsa_stream[i], chip) != 0)
-				ret = -1;			
-		}
+	/* Stop the audio service */
+	if (instance) {
+		vc_vchi_audio_deinit(instance);
+		alsa_stream->instance = NULL;
 	}
-	audio_debug(" .. OUT ret=%d\n", ret);
+	LOG_DBG(" .. OUT\n");
 	return ret;
 }
 
@@ -783,10 +737,9 @@ int bcm2835_audio_write(bcm2835_alsa_stream_t * alsa_stream, uint32_t count,
 	int32_t success;
 	int ret;
 
-	audio_debug(" .. IN outstanding=%d\n", atomic_read(&instance->callbacks_expected)-atomic_read(&instance->callbacks_received));
+	LOG_DBG(" .. IN\n");
 
-	audio_info
-	    (" Writing %d bytes from %p\n", count, src);
+	LOG_INFO(" Writing %d bytes from %p\n", count, src);
 
 	vcos_mutex_lock(&instance->vchi_mutex);
 	vchi_service_use(instance->vchi_handle[0]);
@@ -797,8 +750,7 @@ int bcm2835_audio_write(bcm2835_alsa_stream_t * alsa_stream, uint32_t count,
 	m.u.write.cookie = alsa_stream;
 	m.u.write.silence = src == NULL;
 
-	atomic_add(1, &instance->callbacks_expected);
-	// Send the message to the videocore
+	/* Send the message to the videocore */
 	success = vchi_msg_queue(instance->vchi_handle[0],
 				 &m, sizeof m,
 				 VCHI_FLAGS_BLOCK_UNTIL_QUEUED, NULL);
@@ -810,11 +762,14 @@ int bcm2835_audio_write(bcm2835_alsa_stream_t * alsa_stream, uint32_t count,
 		ret = -1;
 		goto unlock;
 	}
-        audio_debug(" ... send header\n");
+	LOG_DBG(" ... send header\n");
 
-	// Send the message to the videocore
+	/* Send the message to the videocore */
 	success = vchi_bulk_queue_transmit(instance->vchi_handle[0],
-				 src, count, 0*VCHI_FLAGS_BLOCK_UNTIL_QUEUED + 1*VCHI_FLAGS_BLOCK_UNTIL_DATA_READ, NULL);
+					   src, count,
+					   0 * VCHI_FLAGS_BLOCK_UNTIL_QUEUED +
+					   1 * VCHI_FLAGS_BLOCK_UNTIL_DATA_READ,
+					   NULL);
 	if (success != 0) {
 		LOG_ERR("%s: failed on vchi_msg_queue (status=%d)",
 			__func__, success);
@@ -825,12 +780,9 @@ int bcm2835_audio_write(bcm2835_alsa_stream_t * alsa_stream, uint32_t count,
 	ret = 0;
 
 unlock:
-	if (ret != 0) {
-		atomic_dec(&instance->callbacks_expected);
-	}
 	vchi_service_release(instance->vchi_handle[0]);
 	vcos_mutex_unlock(&instance->vchi_mutex);
-	audio_debug(" .. OUT\n");
+	LOG_DBG(" .. OUT\n");
 	return ret;
 }
 
@@ -839,8 +791,8 @@ unlock:
   */
 void bcm2835_audio_flush_buffers(bcm2835_alsa_stream_t * alsa_stream)
 {
-	audio_debug(" .. IN\n");
-	audio_debug(" .. OUT\n");
+	LOG_DBG(" .. IN\n");
+	LOG_DBG(" .. OUT\n");
 	return;
 }
 
@@ -850,14 +802,13 @@ void bcm2835_audio_flush_buffers(bcm2835_alsa_stream_t * alsa_stream)
   */
 void bcm2835_audio_flush_playback_buffers(bcm2835_alsa_stream_t * alsa_stream)
 {
-	audio_debug(" .. IN\n");
-	audio_debug(" .. OUT\n");
+	LOG_DBG(" .. IN\n");
+	LOG_DBG(" .. OUT\n");
 }
 
-uint32_t bcm2835_audio_retrieve_buffers(bcm2835_alsa_stream_t *alsa_stream)
+uint32_t bcm2835_audio_retrieve_buffers(bcm2835_alsa_stream_t * alsa_stream)
 {
 	uint32_t count = atomic_read(&alsa_stream->retrieved);
 	atomic_sub(count, &alsa_stream->retrieved);
 	return count;
 }
-
diff --git a/sound/arm/bcm2835.c b/sound/arm/bcm2835.c
index 54b06a3..5c09518 100755
--- a/sound/arm/bcm2835.c
+++ b/sound/arm/bcm2835.c
@@ -21,9 +21,9 @@
 
 /* module parameters (see "Module Parameters") */
 /* SNDRV_CARDS: maximum number of cards supported by this module */
-static int index[MAX_SUBSTREAMS] = { [0 ... (MAX_SUBSTREAMS - 1)] = -1};
-static char *id[MAX_SUBSTREAMS] = { [0 ... (MAX_SUBSTREAMS - 1)] = NULL};
-static int enable[MAX_SUBSTREAMS] = { [0 ... (MAX_SUBSTREAMS - 1)] = 1 };
+static int index[MAX_SUBSTREAMS] = {[0 ... (MAX_SUBSTREAMS - 1)] = -1 };
+static char *id[MAX_SUBSTREAMS] = {[0 ... (MAX_SUBSTREAMS - 1)] = NULL };
+static int enable[MAX_SUBSTREAMS] = {[0 ... (MAX_SUBSTREAMS - 1)] = 1 };
 
 /* HACKY global pointers needed for successive probes to work : ssp
  * But compared against the changes we will have to do in VC audio_ipc code
@@ -35,13 +35,12 @@ static int enable[MAX_SUBSTREAMS] = { [0 ... (MAX_SUBSTREAMS - 1)] = 1 };
 static struct snd_card *g_card = NULL;
 static bcm2835_chip_t *g_chip = NULL;
 
-static int snd_bcm2835_free(bcm2835_chip_t *chip)
+static int snd_bcm2835_free(bcm2835_chip_t * chip)
 {
 	kfree(chip);
 	return 0;
 }
 
-
 /* component-destructor
  * (see "Management of Cards and Components")
  */
@@ -50,13 +49,12 @@ static int snd_bcm2835_dev_free(struct snd_device *device)
 	return snd_bcm2835_free(device->device_data);
 }
 
-
 /* chip-specific constructor
  * (see "Management of Cards and Components")
  */
 static int __devinit snd_bcm2835_create(struct snd_card *card,
-        struct platform_device *pdev,
-        bcm2835_chip_t **rchip)
+					struct platform_device *pdev,
+					bcm2835_chip_t ** rchip)
 {
 	bcm2835_chip_t *chip;
 	int err;
@@ -88,9 +86,11 @@ static int __devinit snd_bcm2835_alsa_probe(struct platform_device *pdev)
 	bcm2835_chip_t *chip;
 	struct snd_card *card;
 	int err;
-	printk(KERN_INFO"### snd_bcm2835_alsa_probe %p ###", pdev);
+	printk(KERN_INFO "### snd_bcm2835_alsa_probe %p ###", pdev);
 
-	printk("############ PROBING FOR bcm2835 ALSA device (%d):(%d) ###############\n", dev, enable[dev]);
+	printk
+	    ("############ PROBING FOR bcm2835 ALSA device (%d):(%d) ###############\n",
+	     dev, enable[dev]);
 
 	if (dev >= MAX_SUBSTREAMS)
 		return -ENODEV;
@@ -116,21 +116,21 @@ static int __devinit snd_bcm2835_alsa_probe(struct platform_device *pdev)
 	printk("Creating device/chip ..\n");
 	err = snd_bcm2835_create(g_card, pdev, &chip);
 	if (err < 0) {
-		printk(KERN_ERR"Failed to create bcm2835 chip\n");
+		printk(KERN_ERR "Failed to create bcm2835 chip\n");
 		goto out_bcm2835_create;
 	}
 
 	g_chip = chip;
 	err = snd_bcm2835_new_pcm(chip);
 	if (err < 0) {
-		printk(KERN_ERR"Failed to create new BCM2835 pcm device\n");
+		printk(KERN_ERR "Failed to create new BCM2835 pcm device\n");
 		goto out_bcm2835_new_pcm;
 	}
 
 	printk("Adding controls ..\n");
 	err = snd_bcm2835_new_ctl(chip);
 	if (err < 0) {
-		printk(KERN_ERR"Failed to create new BCM2835 ctl\n");
+		printk(KERN_ERR "Failed to create new BCM2835 ctl\n");
 		goto out_bcm2835_new_ctl;
 	}
 
@@ -147,7 +147,8 @@ add_register_map:
 		printk("Registering card ....\n");
 		err = snd_card_register(card);
 		if (err < 0) {
-			printk(KERN_ERR"Failed to register bcm2835 ALSA card \n");
+			printk(KERN_ERR
+			       "Failed to register bcm2835 ALSA card \n");
 			goto out_card_register;
 		}
 		platform_set_drvdata(pdev, card);
@@ -167,11 +168,11 @@ out_bcm2835_new_pcm:
 out_bcm2835_create:
 	BUG_ON(!g_card);
 	if (snd_card_free(g_card))
-		printk(KERN_ERR"Failed to free Registered alsa card\n");
+		printk(KERN_ERR "Failed to free Registered alsa card\n");
 	g_card = NULL;
 out:
-	dev = SNDRV_CARDS; /* stop more avail_substreams from being probed */
-	printk(KERN_ERR"BCM2835 ALSA Probe failed !!\n");
+	dev = SNDRV_CARDS;	/* stop more avail_substreams from being probed */
+	printk(KERN_ERR "BCM2835 ALSA Probe failed !!\n");
 	return err;
 }
 
@@ -187,14 +188,14 @@ static int snd_bcm2835_alsa_remove(struct platform_device *pdev)
 		snd_card_free((struct snd_card *)drv_data);
 		g_card = NULL;
 		g_chip = NULL;
-	} else  {
-		idx = (uint32_t)drv_data;
+	} else {
+		idx = (uint32_t) drv_data;
 		if (g_card != NULL) {
 			BUG_ON(!g_chip);
 			/* We pass chip device numbers in audio ipc devices
 			 * other than the one we registered our card with
 			 */
-			idx = (uint32_t)drv_data;
+			idx = (uint32_t) drv_data;
 			BUG_ON(!idx || idx > MAX_SUBSTREAMS);
 			g_chip->avail_substreams &= ~(1 << idx);
 			/* There should be atleast one substream registered
@@ -211,7 +212,8 @@ static int snd_bcm2835_alsa_remove(struct platform_device *pdev)
 }
 
 #ifdef CONFIG_PM
-static int snd_bcm2835_alsa_suspend(struct platform_device *pdev, pm_message_t state)
+static int snd_bcm2835_alsa_suspend(struct platform_device *pdev,
+				    pm_message_t state)
 {
 	return 0;
 }
@@ -223,119 +225,110 @@ static int snd_bcm2835_alsa_resume(struct platform_device *pdev)
 
 #endif
 
-static struct platform_driver bcm2835_alsa0_driver =
-{
-	.probe      = snd_bcm2835_alsa_probe,
-	.remove     = snd_bcm2835_alsa_remove,
+static struct platform_driver bcm2835_alsa0_driver = {
+	.probe = snd_bcm2835_alsa_probe,
+	.remove = snd_bcm2835_alsa_remove,
 #ifdef CONFIG_PM
-	.suspend    = snd_bcm2835_alsa_suspend,
-	.resume     = snd_bcm2835_alsa_resume,
+	.suspend = snd_bcm2835_alsa_suspend,
+	.resume = snd_bcm2835_alsa_resume,
 #endif
-	.driver     = {
-		.name   = "bcm2835_AUD0",
-		.owner  = THIS_MODULE,
-	},
+	.driver = {
+		   .name = "bcm2835_AUD0",
+		   .owner = THIS_MODULE,
+		   },
 };
 
-static struct platform_driver bcm2835_alsa1_driver =
-{
-	.probe      = snd_bcm2835_alsa_probe,
-	.remove     = snd_bcm2835_alsa_remove,
+static struct platform_driver bcm2835_alsa1_driver = {
+	.probe = snd_bcm2835_alsa_probe,
+	.remove = snd_bcm2835_alsa_remove,
 #ifdef CONFIG_PM
-	.suspend    = snd_bcm2835_alsa_suspend,
-	.resume     = snd_bcm2835_alsa_resume,
+	.suspend = snd_bcm2835_alsa_suspend,
+	.resume = snd_bcm2835_alsa_resume,
 #endif
-	.driver     = {
-		.name   = "bcm2835_AUD1",
-		.owner  = THIS_MODULE,
-	},
+	.driver = {
+		   .name = "bcm2835_AUD1",
+		   .owner = THIS_MODULE,
+		   },
 };
 
-static struct platform_driver bcm2835_alsa2_driver =
-{
-	.probe      = snd_bcm2835_alsa_probe,
-	.remove     = snd_bcm2835_alsa_remove,
+static struct platform_driver bcm2835_alsa2_driver = {
+	.probe = snd_bcm2835_alsa_probe,
+	.remove = snd_bcm2835_alsa_remove,
 #ifdef CONFIG_PM
-	.suspend    = snd_bcm2835_alsa_suspend,
-	.resume     = snd_bcm2835_alsa_resume,
+	.suspend = snd_bcm2835_alsa_suspend,
+	.resume = snd_bcm2835_alsa_resume,
 #endif
-	.driver     = {
-		.name   = "bcm2835_AUD2",
-		.owner  = THIS_MODULE,
-	},
+	.driver = {
+		   .name = "bcm2835_AUD2",
+		   .owner = THIS_MODULE,
+		   },
 };
 
-static struct platform_driver bcm2835_alsa3_driver =
-{
-	.probe      = snd_bcm2835_alsa_probe,
-	.remove     = snd_bcm2835_alsa_remove,
+static struct platform_driver bcm2835_alsa3_driver = {
+	.probe = snd_bcm2835_alsa_probe,
+	.remove = snd_bcm2835_alsa_remove,
 #ifdef CONFIG_PM
-	.suspend    = snd_bcm2835_alsa_suspend,
-	.resume     = snd_bcm2835_alsa_resume,
+	.suspend = snd_bcm2835_alsa_suspend,
+	.resume = snd_bcm2835_alsa_resume,
 #endif
-	.driver     = {
-		.name   = "bcm2835_AUD3",
-		.owner  = THIS_MODULE,
-	},
+	.driver = {
+		   .name = "bcm2835_AUD3",
+		   .owner = THIS_MODULE,
+		   },
 };
 
-static struct platform_driver bcm2835_alsa4_driver =
-{
-	.probe      = snd_bcm2835_alsa_probe,
-	.remove     = snd_bcm2835_alsa_remove,
+static struct platform_driver bcm2835_alsa4_driver = {
+	.probe = snd_bcm2835_alsa_probe,
+	.remove = snd_bcm2835_alsa_remove,
 #ifdef CONFIG_PM
-	.suspend    = snd_bcm2835_alsa_suspend,
-	.resume     = snd_bcm2835_alsa_resume,
+	.suspend = snd_bcm2835_alsa_suspend,
+	.resume = snd_bcm2835_alsa_resume,
 #endif
-	.driver     = {
-		.name   = "bcm2835_AUD4",
-		.owner  = THIS_MODULE,
-	},
+	.driver = {
+		   .name = "bcm2835_AUD4",
+		   .owner = THIS_MODULE,
+		   },
 };
 
-static struct platform_driver bcm2835_alsa5_driver =
-{
-	.probe      = snd_bcm2835_alsa_probe,
-	.remove     = snd_bcm2835_alsa_remove,
+static struct platform_driver bcm2835_alsa5_driver = {
+	.probe = snd_bcm2835_alsa_probe,
+	.remove = snd_bcm2835_alsa_remove,
 #ifdef CONFIG_PM
-	.suspend    = snd_bcm2835_alsa_suspend,
-	.resume     = snd_bcm2835_alsa_resume,
+	.suspend = snd_bcm2835_alsa_suspend,
+	.resume = snd_bcm2835_alsa_resume,
 #endif
-	.driver     = {
-		.name   = "bcm2835_AUD5",
-		.owner  = THIS_MODULE,
-	},
+	.driver = {
+		   .name = "bcm2835_AUD5",
+		   .owner = THIS_MODULE,
+		   },
 };
 
-static struct platform_driver bcm2835_alsa6_driver =
-{
-	.probe      = snd_bcm2835_alsa_probe,
-	.remove     = snd_bcm2835_alsa_remove,
+static struct platform_driver bcm2835_alsa6_driver = {
+	.probe = snd_bcm2835_alsa_probe,
+	.remove = snd_bcm2835_alsa_remove,
 #ifdef CONFIG_PM
-	.suspend    = snd_bcm2835_alsa_suspend,
-	.resume     = snd_bcm2835_alsa_resume,
+	.suspend = snd_bcm2835_alsa_suspend,
+	.resume = snd_bcm2835_alsa_resume,
 #endif
-	.driver     = {
-		.name   = "bcm2835_AUD6",
-		.owner  = THIS_MODULE,
-	},
+	.driver = {
+		   .name = "bcm2835_AUD6",
+		   .owner = THIS_MODULE,
+		   },
 };
 
-static struct platform_driver bcm2835_alsa7_driver =
-{
-	.probe      = snd_bcm2835_alsa_probe,
-	.remove     = snd_bcm2835_alsa_remove,
+static struct platform_driver bcm2835_alsa7_driver = {
+	.probe = snd_bcm2835_alsa_probe,
+	.remove = snd_bcm2835_alsa_remove,
 #ifdef CONFIG_PM
-	.suspend    = snd_bcm2835_alsa_suspend,
-	.resume     = snd_bcm2835_alsa_resume,
+	.suspend = snd_bcm2835_alsa_suspend,
+	.resume = snd_bcm2835_alsa_resume,
 #endif
-	.driver     = {
-		.name   = "bcm2835_AUD7",
-		.owner  = THIS_MODULE,
-	},
+	.driver = {
+		   .name = "bcm2835_AUD7",
+		   .owner = THIS_MODULE,
+		   },
 };
 
-
 static int __devinit bcm2835_alsa_device_init(void)
 {
 	int err;
@@ -386,7 +379,8 @@ static int __devinit bcm2835_alsa_device_init(void)
 		printk("Error registering bcm2835_alsa7_driver %d .\n", err);
 		goto unregister_6;
 	}
-	printk(KERN_INFO"### BCM2835 ALSA driver init %s ### \n",err ? "FAILED": "OK");
+	printk(KERN_INFO "### BCM2835 ALSA driver init %s ### \n",
+	       err ? "FAILED" : "OK");
 
 	return 0;
 
@@ -408,19 +402,22 @@ out:
 	return err;
 }
 
-
-
 static void __devexit bcm2835_alsa_device_exit(void)
 {
-    platform_driver_unregister(&bcm2835_alsa0_driver);
-    platform_driver_unregister(&bcm2835_alsa1_driver);
-    platform_driver_unregister(&bcm2835_alsa2_driver);
-    platform_driver_unregister(&bcm2835_alsa3_driver);
-    platform_driver_unregister(&bcm2835_alsa4_driver);
-    platform_driver_unregister(&bcm2835_alsa5_driver);
-    platform_driver_unregister(&bcm2835_alsa6_driver);
-    platform_driver_unregister(&bcm2835_alsa7_driver);
+	platform_driver_unregister(&bcm2835_alsa0_driver);
+	platform_driver_unregister(&bcm2835_alsa1_driver);
+	platform_driver_unregister(&bcm2835_alsa2_driver);
+	platform_driver_unregister(&bcm2835_alsa3_driver);
+	platform_driver_unregister(&bcm2835_alsa4_driver);
+	platform_driver_unregister(&bcm2835_alsa5_driver);
+	platform_driver_unregister(&bcm2835_alsa6_driver);
+	platform_driver_unregister(&bcm2835_alsa7_driver);
 }
 
 late_initcall(bcm2835_alsa_device_init);
 module_exit(bcm2835_alsa_device_exit);
+
+MODULE_AUTHOR("Dom Cobley");
+MODULE_DESCRIPTION("Alsa driver for BCM2835 chip");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:bcm2835_alsa");
diff --git a/sound/arm/bcm2835.h b/sound/arm/bcm2835.h
index d1d46ad..5b91037 100755
--- a/sound/arm/bcm2835.h
+++ b/sound/arm/bcm2835.h
@@ -13,7 +13,7 @@
 *****************************************************************************/
 
 #ifndef __SOUND_ARM_BCM2835_H
-#define __SOUND_ARM_BCM2835_H 
+#define __SOUND_ARM_BCM2835_H
 
 #define SUBSTREAM_NUM 1
 
@@ -74,39 +74,39 @@
 #define AUDIO_IPC_BLOCK_BUFFER_SIZE    (1024*8)
 
 #define AUDIO_CONTROL_OFFSET			(0x00)
-	#define CTRL_EN_SHIFT			(0)
-	#define CTRL_EN_MASK			(0x00000001)
-	#define CTRL_PLAY_SHIFT			(1)
-	#define CTRL_PLAY_MASK			(0x00000002)
-	#define CTRL_MUTE_SHIFT			(2)
-	#define CTRL_MUTE_MASK			(0x00000004)
-	#define CTRL_SETUP_SHIFT		(3)
-	#define CTRL_SETUP_MASK			(0x00000008)
-	#define CTRL_FLUSH_SHIFT	    (4)
-	#define CTRL_FLUSH_MASK			(0x00000010)
-    #define CTRL_STOPMODE_SHIFT	    (5)
-	#define CTRL_STOPMODE_MASK		(0x00000020)
+#define CTRL_EN_SHIFT			(0)
+#define CTRL_EN_MASK			(0x00000001)
+#define CTRL_PLAY_SHIFT			(1)
+#define CTRL_PLAY_MASK			(0x00000002)
+#define CTRL_MUTE_SHIFT			(2)
+#define CTRL_MUTE_MASK			(0x00000004)
+#define CTRL_SETUP_SHIFT		(3)
+#define CTRL_SETUP_MASK			(0x00000008)
+#define CTRL_FLUSH_SHIFT	    (4)
+#define CTRL_FLUSH_MASK			(0x00000010)
+#define CTRL_STOPMODE_SHIFT	    (5)
+#define CTRL_STOPMODE_MASK		(0x00000020)
 
 #define AUDIO_STATUS_OFFSET			(0x04)
-	#define STAT_EN_SHIFT			(0)
-	#define STAT_EN_MASK			(0x00000001)
-	#define STAT_PLAY_SHIFT			(1)
-	#define STAT_PLAY_MASK			(0x00000002)
-	#define STAT_MUTE_SHIFT			(2)
-	#define STAT_MUTE_MASK			(0x00000004)
-	#define STAT_SETUP_SHIFT		(3)
-	#define STAT_SETUP_MASK			(0x00000008)
-	#define STAT_FLUSH_SHIFT	    (4)
-	#define STAT_FLUSH_MASK			(0x00000010)
-	#define STAT_STOPMODE_SHIFT	    (5)
-	#define STAT_STOPMODE_MASK		(0x00000020)
+#define STAT_EN_SHIFT			(0)
+#define STAT_EN_MASK			(0x00000001)
+#define STAT_PLAY_SHIFT			(1)
+#define STAT_PLAY_MASK			(0x00000002)
+#define STAT_MUTE_SHIFT			(2)
+#define STAT_MUTE_MASK			(0x00000004)
+#define STAT_SETUP_SHIFT		(3)
+#define STAT_SETUP_MASK			(0x00000008)
+#define STAT_FLUSH_SHIFT	    (4)
+#define STAT_FLUSH_MASK			(0x00000010)
+#define STAT_STOPMODE_SHIFT	    (5)
+#define STAT_STOPMODE_MASK		(0x00000020)
 
 /* Interrupt status */
 #define AUDIO_INTSTAT_OFFSET			(0x08)
-	#define INTSTAT_CONTROL_SHIFT		(0)
-	#define INTSTAT_CONTROL_MASK		(0x0000000f)
-	#define INTSTAT_FIFO_SHIFT		(4)
-	#define INTSTAT_FIFO_MASK		(0x000000f0)
+#define INTSTAT_CONTROL_SHIFT		(0)
+#define INTSTAT_CONTROL_MASK		(0x0000000f)
+#define INTSTAT_FIFO_SHIFT		(4)
+#define INTSTAT_FIFO_MASK		(0x000000f0)
 
 /* Configuration */
 #define AUDIO_DESTINATION_OFFSET		(0x0C)
@@ -139,12 +139,12 @@
 /* 8 entries here of 4 words each = 0x80 gap from 0xF0 */
 #define AUDIO_OUT_FIFO_OFFSET			(0xF0)
 
-
 /* Some constants for values .. */
 typedef enum {
-	AUDIO_DEST_LOCAL = 0,
-	AUDIO_DEST_HDMI	= 2,
-	AUDIO_DEST_ALL = 3,
+	AUDIO_DEST_AUTO = 0,
+	AUDIO_DEST_HEADPHONES = 1,
+	AUDIO_DEST_HDMI = 2,
+	AUDIO_DEST_MAX,
 } SND_BCM2835_ROUTE_T;
 
 typedef enum {
@@ -154,8 +154,7 @@ typedef enum {
 } SND_BCM2835_CTRL_T;
 
 /* this struct is tightly packed - its size is 16bytes */
-typedef struct
-{
+typedef struct {
 	uint32_t buffer_id;
 	uint32_t buffer_size;
 	uint32_t buffer_ptr;
@@ -179,13 +178,13 @@ typedef struct bcm2835_chip {
 
 typedef struct bcm2835_audio_buffer {
 	uint32_t buffer_id;
-	phys_addr_t	bus_addr;
-	uint8_t __iomem	*start;
+	phys_addr_t bus_addr;
+	uint8_t __iomem *start;
 	uint32_t size;
 	uint32_t data_left;
 	struct list_head link;
 
-} bcm2835_audio_buffer_t; 
+} bcm2835_audio_buffer_t;
 
 typedef struct bcm2835_alsa_stream {
 	bcm2835_chip_t *chip;
@@ -215,25 +214,29 @@ typedef struct bcm2835_alsa_stream {
 	atomic_t retrieved;
 	struct opaque_AUDIO_INSTANCE_T *instance;
 	struct workqueue_struct *my_wq;
+	int idx;
 } bcm2835_alsa_stream_t;
 
-int snd_bcm2835_new_ctl(bcm2835_chip_t *chip);
-int snd_bcm2835_new_pcm(bcm2835_chip_t *chip);
-
-void bcm2835_audio_fifo_get_lock(bcm2835_alsa_stream_t *alsa_stream);
-void bcm2835_audio_fifo_put_lock(bcm2835_alsa_stream_t *alsa_stream);
-
-int bcm2835_audio_open(bcm2835_alsa_stream_t *alsa_stream);
-int bcm2835_audio_close(bcm2835_alsa_stream_t *alsa_stream);
-int bcm2835_audio_set_params(bcm2835_alsa_stream_t *alsa_stream, uint32_t channels, uint32_t samplerate, uint32_t bps);
-int bcm2835_audio_setup(bcm2835_alsa_stream_t *alsa_stream);
-int bcm2835_audio_start(bcm2835_alsa_stream_t *alsa_stream);
-int bcm2835_audio_stop(bcm2835_alsa_stream_t *alsa_stream);
-int bcm2835_audio_set_ctls(bcm2835_chip_t *chip);
-int bcm2835_audio_write(bcm2835_alsa_stream_t *alsa_stream, uint32_t count, void *src);
+int snd_bcm2835_new_ctl(bcm2835_chip_t * chip);
+int snd_bcm2835_new_pcm(bcm2835_chip_t * chip);
+
+void bcm2835_audio_fifo_get_lock(bcm2835_alsa_stream_t * alsa_stream);
+void bcm2835_audio_fifo_put_lock(bcm2835_alsa_stream_t * alsa_stream);
+
+int bcm2835_audio_open(bcm2835_alsa_stream_t * alsa_stream);
+int bcm2835_audio_close(bcm2835_alsa_stream_t * alsa_stream);
+int bcm2835_audio_set_params(bcm2835_alsa_stream_t * alsa_stream,
+			     uint32_t channels, uint32_t samplerate,
+			     uint32_t bps);
+int bcm2835_audio_setup(bcm2835_alsa_stream_t * alsa_stream);
+int bcm2835_audio_start(bcm2835_alsa_stream_t * alsa_stream);
+int bcm2835_audio_stop(bcm2835_alsa_stream_t * alsa_stream);
+int bcm2835_audio_set_ctls(bcm2835_chip_t * chip);
+int bcm2835_audio_write(bcm2835_alsa_stream_t * alsa_stream, uint32_t count,
+			void *src);
 //uint32_t bcm2835_audio_buffers_consumed_bytes(bcm2835_alsa_stream_t *alsa_stream);
-uint32_t bcm2835_audio_retrieve_buffers(bcm2835_alsa_stream_t *alsa_stream);
-void bcm2835_audio_flush_buffers(bcm2835_alsa_stream_t *alsa_stream);
-void bcm2835_audio_flush_playback_buffers(bcm2835_alsa_stream_t *alsa_stream);
+uint32_t bcm2835_audio_retrieve_buffers(bcm2835_alsa_stream_t * alsa_stream);
+void bcm2835_audio_flush_buffers(bcm2835_alsa_stream_t * alsa_stream);
+void bcm2835_audio_flush_playback_buffers(bcm2835_alsa_stream_t * alsa_stream);
 
 #endif /* __SOUND_ARM_BCM2835_H */
diff --git a/sound/arm/vc_vchi_audioserv_defs.h b/sound/arm/vc_vchi_audioserv_defs.h
index 3f41ff9..d610734 100644
--- a/sound/arm/vc_vchi_audioserv_defs.h
+++ b/sound/arm/vc_vchi_audioserv_defs.h
@@ -23,106 +23,90 @@
 
 // List of screens that are currently supported
 // All message types supported for HOST->VC direction
-typedef enum
-{
-   VC_AUDIO_MSG_TYPE_RESULT,              // Generic result
-   VC_AUDIO_MSG_TYPE_COMPLETE,              // Generic result
-   VC_AUDIO_MSG_TYPE_CONFIG,                 // Configure audio
-   VC_AUDIO_MSG_TYPE_CONTROL,                 // Configure audio
-   VC_AUDIO_MSG_TYPE_OPEN,                 // Configure audio
-   VC_AUDIO_MSG_TYPE_CLOSE,                 // Configure audio
-   VC_AUDIO_MSG_TYPE_START,                 // Configure audio
-   VC_AUDIO_MSG_TYPE_STOP,                 // Configure audio
-   VC_AUDIO_MSG_TYPE_WRITE,                 // Configure audio
-   VC_AUDIO_MSG_TYPE_MAX
-
+typedef enum {
+	VC_AUDIO_MSG_TYPE_RESULT,	// Generic result
+	VC_AUDIO_MSG_TYPE_COMPLETE,	// Generic result
+	VC_AUDIO_MSG_TYPE_CONFIG,	// Configure audio
+	VC_AUDIO_MSG_TYPE_CONTROL,	// Configure audio
+	VC_AUDIO_MSG_TYPE_OPEN,	// Configure audio
+	VC_AUDIO_MSG_TYPE_CLOSE,	// Configure audio
+	VC_AUDIO_MSG_TYPE_START,	// Configure audio
+	VC_AUDIO_MSG_TYPE_STOP,	// Configure audio
+	VC_AUDIO_MSG_TYPE_WRITE,	// Configure audio
+	VC_AUDIO_MSG_TYPE_MAX
 } VC_AUDIO_MSG_TYPE;
 
-
 // configure the audio
-typedef struct
-{
-   uint32_t channels;
-   uint32_t samplerate;
-   uint32_t bps;
+typedef struct {
+	uint32_t channels;
+	uint32_t samplerate;
+	uint32_t bps;
 
 } VC_AUDIO_CONFIG_T;
 
-typedef struct
-{
-   uint32_t volume;
-   uint32_t dest;
+typedef struct {
+	uint32_t volume;
+	uint32_t dest;
 
 } VC_AUDIO_CONTROL_T;
 
 // audio
-typedef struct
-{
-   uint32_t dummy;
+typedef struct {
+	uint32_t dummy;
 
 } VC_AUDIO_OPEN_T;
 
 // audio
-typedef struct
-{
-   uint32_t dummy;
+typedef struct {
+	uint32_t dummy;
 
 } VC_AUDIO_CLOSE_T;
 // audio
-typedef struct
-{
-   uint32_t dummy;
+typedef struct {
+	uint32_t dummy;
 
 } VC_AUDIO_START_T;
 // audio
-typedef struct
-{
-   uint32_t draining;
+typedef struct {
+	uint32_t draining;
 
 } VC_AUDIO_STOP_T;
 
 // configure the write audio samples
-typedef struct
-{
-   uint32_t count; // in bytes
-   void *callback;
-   void *cookie;
-   uint32_t silence;
+typedef struct {
+	uint32_t count;		// in bytes
+	void *callback;
+	void *cookie;
+	uint32_t silence;
 } VC_AUDIO_WRITE_T;
 
 // Generic result for a request (VC->HOST)
-typedef struct
-{
-   int32_t success;  // Success value
+typedef struct {
+	int32_t success;	// Success value
 
 } VC_AUDIO_RESULT_T;
 
 // Generic result for a request (VC->HOST)
-typedef struct
-{
-   int32_t count;  // Success value
-   void *callback;
-   void *cookie;
+typedef struct {
+	int32_t count;		// Success value
+	void *callback;
+	void *cookie;
 } VC_AUDIO_COMPLETE_T;
 
 // Message header for all messages in HOST->VC direction
-typedef struct
-{
-   int32_t type;     // Message type (VC_AUDIO_MSG_TYPE)
-   union
-   {
-	VC_AUDIO_CONFIG_T    config;
-   VC_AUDIO_CONTROL_T   control;
-	VC_AUDIO_OPEN_T  open;
-	VC_AUDIO_CLOSE_T  close;
-	VC_AUDIO_START_T  start;
-	VC_AUDIO_STOP_T  stop;
-	VC_AUDIO_WRITE_T  write;
-	VC_AUDIO_RESULT_T result;
-	VC_AUDIO_COMPLETE_T complete;
-   } u;
+typedef struct {
+	int32_t type;		// Message type (VC_AUDIO_MSG_TYPE)
+	union {
+		VC_AUDIO_CONFIG_T config;
+		VC_AUDIO_CONTROL_T control;
+		VC_AUDIO_OPEN_T open;
+		VC_AUDIO_CLOSE_T close;
+		VC_AUDIO_START_T start;
+		VC_AUDIO_STOP_T stop;
+		VC_AUDIO_WRITE_T write;
+		VC_AUDIO_RESULT_T result;
+		VC_AUDIO_COMPLETE_T complete;
+	} u;
 } VC_AUDIO_MSG_T;
 
-
 #endif // _VC_AUDIO_DEFS_H_
-
